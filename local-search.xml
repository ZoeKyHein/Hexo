<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【GolangBot】9-循环</title>
    <link href="/%E3%80%90GolangBot%E3%80%919-%E5%BE%AA%E7%8E%AF/"/>
    <url>/%E3%80%90GolangBot%E3%80%919-%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="【GolangBot】9-循环"><a href="#【GolangBot】9-循环" class="headerlink" title="【GolangBot】9-循环"></a>【GolangBot】9-循环</h1><p>欢迎来到Golang教程系列的第9课</p><p>循环用于重复执行一段代码，直到满足某个条件为止。</p><p>在Go中，<code>for</code> 是唯一的循环。Go没有像C语言那样的<code>while</code>或<code>do while</code>循环。</p><h3 id="for-循环语法"><a href="#for-循环语法" class="headerlink" title="for 循环语法"></a>for 循环语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> 初始化; 条件; 后续操作 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化语句只会执行一次。循环初始化后，会检查条件。如果条件为真，则会执行 <code>&#123;&#125;</code> 中的循环体代码，然后执行后续操作语句。后续操作语句会在每次成功迭代后执行。执行完后续操作语句后，会再次检查条件。如果条件为真，循环将继续执行，否则<code>for</code>循环终止。</p><p>在Go中，初始化、条件和后续操作这三个部分都是可选的。让我们通过一个例子来更好地理解<code>for</code>循环。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们来写一个程序，使用<code>for</code>循环打印从1到10的数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/C7lOa1D_0-1">在Playground中运行</a></p><p>在上述程序中，<code>i</code>被初始化为1。条件语句检查<code>i &lt;= 10</code>是否为真。如果条件为真，则打印<code>i</code>的值，否则循环终止。后续操作语句在每次迭代结束时将<code>i</code>增加1。一旦<code>i</code>大于10，循环终止。</p><p>上述程序将打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">1 2 3 4 5 6 7 8 9 10<br></code></pre></td></tr></table></figure><p>在<code>for</code>循环中声明的变量只能在循环的作用域内访问。因此，<code>i</code>无法在<code>for</code>循环体外部访问。</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p><code>break</code>语句用于在<code>for</code>循环完成正常执行之前中断循环，并将控制转移到<code>for</code>循环之后的代码行。</p><p>让我们修改上述程序，使其在打印到5时中断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">5</span> &#123;<br><span class="hljs-keyword">break</span> <span class="hljs-comment">//如果i &gt; 5，循环终止</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;</span><br><span class="hljs-string">loop ended&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/v5MIpHz6H6J">在Playground中运行</a></p><p>在上述程序中，每次迭代都会检查<code>i</code>的值。如果<code>i</code>大于5，则执行<code>break</code>并终止循环。随后执行循环之后的打印语句。上述程序将输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">1 2 3 4 5 <br>loop ended<br></code></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p><code>continue</code>语句用于跳过当前迭代的剩余代码。<code>for</code>循环中<code>continue</code>之后的所有代码在当前迭代中将不会被执行。循环将直接跳到下一次迭代。</p><p>让我们编写一个程序，使用<code>continue</code>打印1到10之间的所有奇数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/ZGsEFZzxYhD">在Playground中运行</a></p><p>在上述程序中，第9行检查<code>i</code>除以2的余数是否为0。如果为0，则数字是偶数，执行<code>continue</code>语句，控制直接跳到循环的下一次迭代。因此，<code>continue</code>后的打印语句不会被调用，循环进入下一次迭代。上述程序的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">1 3 5 7 9<br></code></pre></td></tr></table></figure><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>一个<code>for</code>循环如果里面还有另一个<code>for</code>循环，那它就被称为嵌套循环。</p><p>我们写个程序打印如下序列来了解嵌套循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fallback">*<br>**<br>***<br>****<br>*****<br></code></pre></td></tr></table></figure><p>下面的程序使用嵌套打印序列。第8行的变量<code>n</code>存储了序列的行数。在我们的示例中是<code>5</code>。外层循环<code>i</code>从<code>0</code>迭代到<code>4</code>，内层循环<code>j</code>从<code>0</code>迭代到当前<code>i</code>的值。内层循环每次迭代都会打印<code>*</code>，外层循环每次迭代都会打印一个空行。运行这个程序你会看到序列打印出来作为输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= i; j++ &#123;<br>fmt.Print(<span class="hljs-string">&quot;*&quot;</span>)<br>&#125;<br>fmt.Println()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/0rq8fWjVDLb">Run in playground</a></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>标签可以用来从内层循环内部终止外层循环。让我们用一个简单的例子来理解这是什么意思。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; j++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;i = %d , j = %d\n&quot;</span>, i, j)<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/BnCKho2x5hM">Run in playground</a></p><p>上面的程序的作用不言自明，它会打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fallback">i = 0 , j = 1<br>i = 0 , j = 2<br>i = 0 , j = 3<br>i = 1 , j = 1<br>i = 1 , j = 2<br>i = 1 , j = 3<br>i = 2 , j = 1<br>i = 2 , j = 2<br>i = 2 , j = 3<br></code></pre></td></tr></table></figure><p>在这里没什么特别的:)。</p><p>如果我想在<code>i</code>和<code>j</code>相等的时候停止打印该怎么办呢？为了达成目的，我们需要从外层<code>for</code>循环<code>break</code>。当内层<code>for</code>循环<code>i</code>和<code>j</code>相等的时候添加一个<code>break</code>，将会只结束内层<code>for</code>循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; j++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;i = %d , j = %d\n&quot;</span>, i, j)<br><span class="hljs-keyword">if</span> i == j &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/uMjbF8Ii41d">Run in playground</a></p><p>在上面的程序中，我已经在第10行内层<code>for</code>循环<code>i</code>和<code>j</code>相等的时候添加了一个<code>break</code>。这只是<code>break</code>掉了内层循环，而外层循环还在继续。这个程序将会打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fallback">i = 0 , j = 1<br>i = 0 , j = 2<br>i = 0 , j = 3<br>i = 1 , j = 1<br>i = 2 , j = 1<br>i = 2 , j = 2<br></code></pre></td></tr></table></figure><p>这不是我们预期的输出。我们需要在<code>i</code>和<code>j</code>相等的时候停止打印，比如他们都等于<code>1</code>的时候。</p><p>这时就需要标签来救我们了。标签可以用来终止外层循环。我们用标签重写上面的程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>outer:<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; j++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;i = %d , j = %d\n&quot;</span>, i, j)<br><span class="hljs-keyword">if</span> i == j &#123;<br><span class="hljs-keyword">break</span> outer<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/BI10Rmp_Z3y">Run in playground</a></p><p>在上面的程序中，我们已经为外层循环在第8行添加了一个<code>outer</code>标签，并且我们在第13行已通过指定标签break了外层循环。这个程序将会在<code>i</code>和<code>j</code>相等的时候停止打印。程序将会输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fallback">i = 0 , j = 1<br>i = 0 , j = 2<br>i = 0 , j = 3<br>i = 1 , j = 1<br></code></pre></td></tr></table></figure><h3 id="使用for循环实现while循环"><a href="#使用for循环实现while循环" class="headerlink" title="使用for循环实现while循环"></a>使用for循环实现while循环</h3><p>我们在前面讨论过，<code>for</code>循环是go中唯一可用的循环语句。我们可以使用for循环的变体来实现<code>while</code>循环的功能。让我们来讨论一下如何实现。下面的程序打印从0到10的所有偶数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ;i &lt;= <span class="hljs-number">10</span>; &#123; <span class="hljs-comment">// initialisation and post are omitted</span><br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)<br>i += <span class="hljs-number">2</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/xstHXjQrWcc">Run in playground</a></p><p>我们已经知道for循环的所有三个组成部分，即初始化、条件和后置条件，它们都是可选的。在山脉呢程序中忽略了初始化和后置条件。<code>i</code>在循环外面被初始化为<code>0</code>。只要<code>i&lt;=10</code>循环就会执行。<code>i</code>在循环内每次加<code>2</code>。上面的程序将会打印<code>0 2 4 6 8 10 </code>。</p><p>上面程序中循环的封号也可以被省略。这种格式可以看作是<code>while</code>循环的一种替代格式。上面的程序可以重写为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt;= <span class="hljs-number">10</span> &#123; <span class="hljs-comment">//semicolons are ommitted and only condition is present. This is similar to while loop.</span><br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)<br>i += <span class="hljs-number">2</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/4kU5944zDto">Run in playground</a></p><h3 id="多重变量声明"><a href="#多重变量声明" class="headerlink" title="多重变量声明"></a>多重变量声明</h3><p>在一个<code>for</code>循环中声明和操作多个变量也是可以的。让我们写一个程序，用多重变量声明来打印如下的序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fallback">10 * 1 = 10<br>11 * 2 = 22<br>12 * 3 = 36<br>13 * 4 = 52<br>14 * 5 = 70<br>15 * 6 = 90<br>16 * 7 = 112<br>17 * 8 = 136<br>18 * 9 = 162<br>19 * 10 = 190<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> no, i := <span class="hljs-number">10</span>, <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span> &amp;&amp; no &lt;= <span class="hljs-number">19</span>; i, no = i+<span class="hljs-number">1</span>, no+<span class="hljs-number">1</span> &#123; <span class="hljs-comment">//multiple initialisation and increment</span><br>fmt.Printf(<span class="hljs-string">&quot;%d * %d = %d\n&quot;</span>, no, i, no*i)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/oFcmLl3NHzK">Run in playground</a></p><p>在上面的程序中<code>no</code>和<code>i</code>被声明，并且分别被初始化为10和1。每次循环结束后它们增加1。布尔操作符<code>&amp;&amp;</code>被用在条件里，它用来确保<code>i</code>小于等于10并且<code>no</code>小于等于19。</p><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>创建一个死循环的语法如下，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的程序将会持续不断地打印<code>Hello World</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你尝试着在<a href="https://go.dev/play/p/3Dmj7QVbQJz">在线环境</a>运行上面的程序，你会得到错误<code>timeout running program</code>。请试着在你的本地环境运行，打印无限多的”Hello World”。</p><p>还有一种结构<strong>range</strong>可以在<code>for</code>循环中用于<a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">数组操作</a>。我们将会在数组章节来探讨它。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9110-switch%E8%AF%AD%E5%8F%A5/">switch语句</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GoLangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】8-if else语句</title>
    <link href="/%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/"/>
    <url>/%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="【GolangBot】8-if-else语句"><a href="#【GolangBot】8-if-else语句" class="headerlink" title="【GolangBot】8-if else语句"></a>【GolangBot】8-if else语句</h1><p>欢迎来到<a href="../GolangBot/">Golang系列教程</a>的第八篇。</p><p><strong><code>if</code>语句有个条件，如果这个条件值为<code>true</code>，它就会执行一段代码块。如果条件为<code>false</code>，就会执行另一段代码块。</strong>在这个教程中，我们会看一下使用<code>if</code>语句的不同语法。</p><h3 id="If-语句语法"><a href="#If-语句语法" class="headerlink" title="If 语句语法"></a>If 语句语法</h3><p>下面是<code>if</code>语句的语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">if condition &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<code>condition</code>运算为<code>true</code>，在<code>&#123;</code> 和 <code>&#125;</code>之间的代码块将被执行。</p><p>与C语言括号<code>&#123;&#125;</code>是可选的不同，即使<code>&#123;&#125;</code>之间只有一行语句，括号也是强制的。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们来写一个简单的示例判断一个数字是奇数还是偶数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>num := <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span><br>fmt.Println(<span class="hljs-string">&quot;The number&quot;</span>, num, <span class="hljs-string">&quot;is even&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;The number&quot;</span>, num, <span class="hljs-string">&quot;is odd&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/RRxkgK07ul4">Run in Playground</a></p><p>在上面的程序中，第9行的条件<code>num%2</code>检测<code>num</code>除以<code>2</code>的余数是不是0。因为在这个例子中是<code>0</code>，文本<code>The number 10 is even</code>被打印，然后程序退出。</p><h3 id="If-else-语句"><a href="#If-else-语句" class="headerlink" title="If else 语句"></a>If else 语句</h3><p><code>if</code>语句有一个可选结构，<code>else</code>语句，如果<code>if</code>语句的值是<code>false</code>，它就会执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fallback">if condition &#123;<br>&#125; else &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的片段中，如果<code>condition</code>的值是<code>false</code>，那么在<code>else &#123;</code> 和 <code>&#125;</code>之间的代码就会被执行。</p><p>让我们用上<code>if else</code>语句重写程序，重新检测数值的奇偶。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>num := <span class="hljs-number">11</span><br><span class="hljs-keyword">if</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span><br>fmt.Println(<span class="hljs-string">&quot;The number&quot;</span>, num, <span class="hljs-string">&quot;is even&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;The number&quot;</span>, num, <span class="hljs-string">&quot;is odd&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/Ku3HivlA5N4">Run in playground</a></p><p>在上面的代码中，与我们在<a href="../%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/#%E7%A4%BA%E4%BE%8B">上一节</a>中直接在条件为true时返回不同，我们创建了一个else语句，该语句会在条件为false时执行。这里，因为11是奇数，所以if条件为false，else语句内的代码会被执行。上述程序将输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">The number 11 is odd<br></code></pre></td></tr></table></figure><h3 id="If-…-else-if-…-else-语句"><a href="#If-…-else-if-…-else-语句" class="headerlink" title="If … else if … else 语句"></a>If … else if … else 语句</h3><p><code>if</code>语句还可以包含可选的<code>else if</code>和<code>else</code>组件。其语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fallback">if condition1 &#123;<br>...<br>&#125; else if condition2 &#123;<br>...<br>&#125; else &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>条件从上到下进行判断。</p><p>在上述语句中，如果<code>condition1</code>为<code>true</code>，那么<code>if condition1 &#123;</code>和紧接着的结束括号<code>&#125;</code>之间的代码块将被执行。</p><p>如果<code>condition1</code>为<code>false</code>且<code>condition2</code>为<code>true</code>，则<code>else if condition2 &#123;</code>和下一个结束括号<code>&#125;</code>之间的代码块将被执行。</p><p>如果<code>condition1</code>和<code>condition2</code>都为<code>false</code>，则<code>else</code>语句中的代码块，即<code>else &#123;</code>和<code>&#125;</code>之间的代码，将会被执行。</p><p>可以包含任意数量的<code>else if</code>语句。</p><p><strong>一般而言，无论是<code>if</code>还是<code>else if</code>，只要条件满足<code>true</code>，相应的代码块就会被执行。如果所有条件都为<code>false</code>，则执行<code>else</code>块中的代码。</strong></p><p>让我们用<code>else if</code>来编写一个公交车票价计算程序。程序需满足以下要求：</p><ul><li>如果乘客的年龄小于5岁，则票免费。</li><li>如果乘客的年龄在5到22岁之间，则票价为10美元。</li><li>如果乘客的年龄超过22岁，则票价为15美元。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>age := <span class="hljs-number">10</span><br>ticketPrice := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">5</span> &#123;<br>ticketPrice = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">5</span> &amp;&amp; age &lt;= <span class="hljs-number">22</span> &#123;<br>ticketPrice = <span class="hljs-number">10</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ticketPrice = <span class="hljs-number">15</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Ticket price is $%d&quot;</span>, ticketPrice)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/CPaydvwiegY">Run in playground</a></p><p>在上述程序中，乘客的年龄被设为<code>10</code>。第12行的条件为<code>true</code>，因此程序将打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Ticket price is $10<br></code></pre></td></tr></table></figure><p>请尝试更改乘客年龄以测试<code>if else</code>语句中不同块是否按预期执行。</p><h3 id="If语句中的赋值"><a href="#If语句中的赋值" class="headerlink" title="If语句中的赋值"></a>If语句中的赋值</h3><p><code>if</code>语句还有一种变体，包含一个可选的<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/#%E7%AE%80%E7%9F%AD%E5%A3%B0%E6%98%8E">简短赋值</a>语句，在条件判断之前执行。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">if assignment-statement; condition &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述语法中，<code>assignment-statement</code>在条件判断前被执行。</p><p>让我们使用这种简短语法重写公交车票价程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ticketPrice := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> age := <span class="hljs-number">10</span>; age &lt; <span class="hljs-number">5</span> &#123;<br>ticketPrice = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">5</span> &amp;&amp; age &lt;= <span class="hljs-number">22</span> &#123;<br>ticketPrice = <span class="hljs-number">10</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ticketPrice = <span class="hljs-number">15</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Ticket price is $%d&quot;</span>, ticketPrice)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/JHmL4h_MB2F">Run in playground</a></p><p>在此程序中，<code>age</code>在第9行的<code>if</code>语句中被初始化。**<code>age</code>只能在<code>if</code>结构中访问。也就是说，它的作用域仅限于<code>if</code>、<code>else if</code>和<code>else</code>块。如果尝试在这些块外访问<code>age</code>，编译器将会报错。**</p><p>这种语法常用于声明仅在<code>if else</code>构造中使用的变量。它能确保变量的作用域只限于<code>if</code>语句。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>else</code>语句必须紧跟在<code>if</code>语句的结束括号<code>&#125;</code>所在的同一行。如果不是，编译器会报错。</p><p>让我们通过一个程序来理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>num := <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span><br>fmt.Println(<span class="hljs-string">&quot;the number is even&quot;</span>) <br>&#125;  <br>    <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;the number is odd&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/RiZ3drcztcI">Run in playground</a></p><p>在上面的程序中，<code>else</code>语句没有紧跟在第11行的<code>if</code>语句结束括号<code>&#125;</code>之后，而是换行写在下一行。这在Go语言中是不允许的。如果运行该程序，编译器会打印如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">./prog.go:12:5: syntax error: unexpected else, expected &#125;<br></code></pre></td></tr></table></figure><p>这是因为Go语言的分号自动插入规则。可以阅读<a href="https://go.dev/ref/spec#Semicolons">此处</a>的语法说明了解更多。</p><p>规则中说明，如果<code>&#125;</code>是该行的最后一个标记，则在<code>&#125;</code>后会自动插入一个分号。因此，Go编译器会在第11行的<code>if</code>语句结束括号<code>&#125;</code>后插入分号。</p><p>因此，程序实际上变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fallback">...<br>if num%2 == 0 &#123; <br>      fmt.Println(&quot;the number is even&quot;) <br>&#125;;  //semicolon inserted by Go Compiler<br>else &#123;<br>      fmt.Println(&quot;the number is odd&quot;)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于<code>if &#123;...&#125; else &#123;...&#125;</code>是一条完整的语句，因此在中间不能有分号。故此程序无法通过编译。因此，<code>else</code>必须紧跟在<code>if</code>语句的结束括号<code>&#125;</code>后。</p><p>让我们重新编写程序，将<code>else</code>放到同一行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>num := <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span><br>fmt.Println(<span class="hljs-string">&quot;the number is even&quot;</span>) <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;the number is odd&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/NKELadXVQse">Run in playground</a></p><p>现在编译器会正常通过，我们也会感到满意 😃。</p><h3 id="Go的惯用写法"><a href="#Go的惯用写法" class="headerlink" title="Go的惯用写法"></a>Go的惯用写法</h3><p>我们已经看到多种<code>if else</code>构造，也看到了多种方式实现相同功能的程序。例如，通过不同的<code>if else</code>构造编写检查数字是奇数还是偶数的程序。那么哪一种是Go语言的惯用写法？<strong>在Go的惯用写法中，最好避免不必要的分支和代码缩进，同时尽可能早地返回。</strong></p><p>我提供了上一节的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> num := <span class="hljs-number">10</span>; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span><br>fmt.Println(num,<span class="hljs-string">&quot;is even&quot;</span>) <br>&#125;  <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(num,<span class="hljs-string">&quot;is odd&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/ed3YK5cM3Hw">Run in playground</a></p><p>在Go中，惯用写法是尽早返回并避免<code>else</code>分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>num := <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span><br>fmt.Println(num, <span class="hljs-string">&quot;is even&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(num, <span class="hljs-string">&quot;is odd&quot;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/JpWZRmFcdSG">Run in playground</a></p><p>在此程序中，当确定数字是偶数后，立即返回。这避免了不必要的<code>else</code>分支。这是Go语言中的推荐做法 😃。编写Go程序时，请牢记这一点。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%919-%E5%BE%AA%E7%8E%AF/">循环</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GoLangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】7-包</title>
    <link href="/%E3%80%90GolangBot%E3%80%917-%E5%8C%85/"/>
    <url>/%E3%80%90GolangBot%E3%80%917-%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../GolangBot/">Golang系列教程</a>的第七篇。</p><h3 id="什么是包？我们为什么要用它？"><a href="#什么是包？我们为什么要用它？" class="headerlink" title="什么是包？我们为什么要用它？"></a>什么是包？我们为什么要用它？</h3><p>到目前为止，我们已经看过了只有一个文件的Go程序，这个文件中有一个main<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数</a>和一些其他的函数。在实际的场景中，把所有的源码都写在一个文件中是不可扩展的。这样编写的代码不太可能复用和维护。这时候包就派上用场了。</p><p><strong>包被用于管理源代码，使其有更好的复用性和可读性。包是所有处于同一目录中文件的集合。包提供了代码分隔功能，因此可以轻松的维护Go项目。</strong></p><p>例如，加入我们正在用Go编写一个金融科技应用，其中一些功能包括单利计算、复利计算和贷款偿还计算。管理这个应用的一个简单的方式是通过功能划分。我们可以创建包<code>simpleinterest</code>, <code>compoundinterest</code> 和 <code>loanrepayment</code>。如果<code>loanrepayment</code>包需要计算单利，它可以直接导入<code>simpleinterest</code>包来完成。这样代码就实现了复用。</p><p>我们将通过创建一个简单的应用来学习包，在给定本金、利率和以年为单位的时间期限的情况下确定单利。</p><h3 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h3><p>我们将以这样的方式来组织代码，所有和单利相关的功能都放在<code>simpleinterest</code>包。为了实现目的，我们需要创建一个自定义包<code>simpleinterest</code>，在这里包含了计算单利的函数。在创建自定义包之前，我们需要先理解Go Modules，因为<strong>Go Modules</strong>被用于创建自定义包。</p><p><strong>Go Module只是Go软件包的集合。</strong>现在你可能想到了一个问题，我们为什么需要Go Modules来创建自定义包？答案是<strong>我们创建的自定义包的导入路径来自Go Modules的名字</strong>。除此之外，所有的第三方包(例如来自github的源码)及其版本都由<code>go.mod</code>文件管理。<code>go.mod</code>文件是我们在创建新模块时创建的。你会在下一节更好地理解它。</p><h3 id="创建一个Go-module"><a href="#创建一个Go-module" class="headerlink" title="创建一个Go module"></a>创建一个Go module</h3><p>运行下面的命令，在当前用户的文档目录下创建一个名为learnpackage的目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">mkdir ~/Documents/learnpackage/ <br></code></pre></td></tr></table></figure><p>通过输入<code>cd !/Documents/learnpackage</code>命令确保你在目录<code>learnpackage</code>当中。在这个目录中运行下面的命令，创建一个名为<em>learnpackage</em>的go module。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">go mod init learnpackage<br></code></pre></td></tr></table></figure><p>上述命令会创建一个名为<code>go.mod</code>的文件。下面是文件中将会出现的内容。</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs v"><span class="hljs-keyword">module</span> learnpackage<br><br>go <span class="hljs-number">1</span><span class="hljs-variable">.21</span><span class="hljs-variable">.0</span><br></code></pre></td></tr></table></figure><p><code>module learnpackage</code>表明模块的名称是<code>learnpackage</code>。正如我们前面提到的，<code>learnpackage</code>将是导入任何在这个模块中创建的包的基础路径。<code>go 1.21.0</code>指定这个模组中的文件使用的go版本是<code>1.21.0</code>。</p><h3 id="创建一个简单的单利自定义包"><a href="#创建一个简单的单利自定义包" class="headerlink" title="创建一个简单的单利自定义包"></a>创建一个简单的单利自定义包</h3><p><strong>属于同一个包的所有Go文件应该被放在它们所属的单独的文件夹内。Go的惯例是将该文件夹命名为与包相同的名称。</strong></p><p>让我们在<code>learnpackage</code>文件夹中创建一个名为<code>simpleinterest</code>的文件夹，<code>mkdir simpleinterest</code>命令将会为我们创建这个文件夹。</p><p><strong><code>package packagename</code>指定某个特定的.go文件属于<code>packagename</code>包。这应该在每个源文件的第一行。</strong>因此所有<em>simpleinterest</em>文件夹中的文件都应该以这行代码开始，因为它们都属于<code>simpleinterest</code>包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> simpleinterest<br></code></pre></td></tr></table></figure><p>在 <em>simpleinterest</em>包中创建一个<code>simpleinterest.go</code>文件。</p><p>下面是我们应用的目录结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fallback">learnpackage/<br>├── go.mod<br>└── simpleinterest<br>    └── simpleinterest.go<br></code></pre></td></tr></table></figure><p>在<code>simpleinterest.go</code>文件中添加如下代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span><span class="hljs-keyword">package</span> simpleinterest<br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><span class="hljs-comment">//Calculate calculates and returns the simple interest for a principal p, rate of interest r for time duration t years</span><br><span class="hljs-number">4</span><span class="hljs-keyword">func</span> Calculate(p <span class="hljs-type">float64</span>, r <span class="hljs-type">float64</span>, t <span class="hljs-type">float64</span>) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-number">5</span>interest := p * (r / <span class="hljs-number">100</span>) * t<br><span class="hljs-number">6</span><span class="hljs-keyword">return</span> interest<br><span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们已经创建了<code>Calculate</code>函数，它能够计算并返回单利。这个函数的作用不言自明。</p><p><em>请注意，函数名称Calculate以大写字母开头。这一点很重要，我们很快就会解释为什么需要这么做。</em></p><h3 id="main包和main函数"><a href="#main包和main函数" class="headerlink" title="main包和main函数"></a>main包和main函数</h3><p>教程的下一步是导入我们刚刚创建的<code>simpleinterest</code>包并且使用它。我们将从<code>main</code>包中导入simpleinterest包。让我们首先来理解一下<code>main</code>函数和<code>main</code>包。</p><p>每个可执行的Go应用都应该包含<code>main</code>函数。这个函数是执行的入口点。<code>main</code>函数应该位于<code>main</code>包中。</p><p>让我们通过为我们的应用创建<code>main</code>函数和<code>main</code>包来开始。</p><p>在我们的<code>learnpackage</code>目录下创建一个名为<code>main.go</code>的文件，其中有以下内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>fmt.Println(<span class="hljs-string">&quot;Simple interest calculation&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>package main</code>指定这个文件属于main包。<code>import packagename</code>语句用来导入一个已经存在的包。<code>packagename.FunctionName()</code>是调用包中函数的语法。</p><p>在第3行，我们导入了<code>fmt</code>包来使用<code>Println</code>函数。<code>fmt</code>是一个标准包，作为Go标准库的一部分提供。然后是打印<code>Simple interest calculation</code>的<code>main</code>函数。</p><p>使用如下命令移动到<code>learnpackage</code>目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">cd ~/Documents/learnpackage/<br></code></pre></td></tr></table></figure><p>用下面的命令，编译上面的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">go build<br></code></pre></td></tr></table></figure><p>如果一切正常，我们的二进制文件将会被编译出来，而且准备好运行。在终端中输入<code>./learnpackage</code>命令，你会看到下面的输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Simple interest calculation<br></code></pre></td></tr></table></figure><p>如果你不理解<code>go build</code>是如何工作的，请前往<a href="../%E3%80%90GolangBot%E3%80%912-Hello-World/">Hello World教程</a>了解详情。</p><h3 id="在main包中印入simpleinterest包"><a href="#在main包中印入simpleinterest包" class="headerlink" title="在main包中印入simpleinterest包"></a>在main包中印入simpleinterest包</h3><p>为了使用自定义包，我们必须先导入它。导入路径是由包所在目录和包名称连接的go module的名称。</p><p>在我们的示例中，go module的名称是<code>learnpackage</code>，<code>simpleinterest</code>包在<code>learnpackage</code>正下方的<code>simpleinterest</code>文件夹中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">├── learnpackage<br>│   └── simpleinterest<br></code></pre></td></tr></table></figure><p>所以<code>import &quot;learnpackage/simpleinterest&quot;</code>这一行会引入<em>simpleinterest</em>包。</p><p>在这种情况下，我们的目录结构是这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fallback">learnpackage<br>│   └── finance<br>│       └── simpleinterest <br></code></pre></td></tr></table></figure><p>导入语句就是<code>import &quot;learnpackage/finance/simpleinterest&quot;</code>。</p><p>添加如下代码到<code>main.go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Simple interest calculation&quot;</span>)<br>p := <span class="hljs-number">5000.0</span><br>r := <span class="hljs-number">10.0</span><br>t := <span class="hljs-number">1.0</span><br>si := simpleinterest.Calculate(p, r, t)<br>fmt.Println(<span class="hljs-string">&quot;Simple interest is&quot;</span>, si)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码引入了<code>simpleinterest</code>包并且使用了<code>Calculate</code>函数求单利。标准库中的包不需要使用模块名作为前缀，因此<code>fmt</code>不需要模组前缀就可以工作。当程序运行时，输出将会是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Simple interest calculation<br>Simple interest is 500<br></code></pre></td></tr></table></figure><h3 id="关于go-build的更多内容"><a href="#关于go-build的更多内容" class="headerlink" title="关于go build的更多内容"></a>关于go build的更多内容</h3><p>现在我们理解了包如何工作，是时候聊一下<code>go build</code>了。像<code>go build</code>的Go工具在当前目录的上下文中工作。我们来理解一下这是什么意思。到目前为止，我们一直在<code>~/Documents/learnpackage</code>中运行<code>go build</code>。如果我们尝试在其他目录中运行，它就会报错。</p><p>试着用<code>cd ~/Documents/</code>进入<code>~/Documents/</code>，然后运行<code>go build learnpackage</code>。它会报下面的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> learnpackage is not in std (/usr/local/<span class="hljs-keyword">go</span>/src/learnpackage)<br></code></pre></td></tr></table></figure><p>我们来理解一下错误背后的原因。<code>go build</code>用一个可选的报名作为参数(在我们的例子中包名是<code>learnpackage</code>)，如果运行时的当前目录、它的父级目录或者父级目录的父级目录，以此类推……存在包，他就会尝试编译main函数。</p><p>我们在<code>Documents</code>目录中，这里没有<code>go.mod</code>文件，因此<code>go build</code>抱怨它找不到<code>learnpackage</code>包。</p><p>当我们移动到<code>~/Documents/learnpackage</code>,这里有<code>go.mod</code>文件，并且在那个<code>go.mode</code>文件中，我们的模组名就是<code>learnpackage</code>。</p><p>所以<code>go build learnpackage</code>在<code>~/Documents/learnpackage/</code>目录中就会奏效。</p><p>但是到目前为止，我们只是使用了<code>go build</code>但并没有指定一个包名。如果没有包名被指定，<code>go build</code>会默认使用当前工作目录下的模块名称。这就是为什么在<code>~/Documents/learnpackage/</code>中不带包名运行<code>go build</code>正常的原因。所以当我们在<code>~/Documents/learnpackage/</code>中运行时，以下3种命令都是同样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fallback">go build<br><br>go build .<br><br>go build learnpackage<br></code></pre></td></tr></table></figure><p>我也提到了<code>go build</code>能够递归搜索父目录的go.mod文件。让我们看下这是否有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">cd ~/Documents/learnpackage/simpleinterest/<br></code></pre></td></tr></table></figure><p>上面的命令让我们进入<code>simpleinterest</code>目录。在这个目录运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">go build learnpackage<br></code></pre></td></tr></table></figure><p><code>go build</code>将会从定义了<code>learnpackage</code>模组的<code>learnpackage</code>目录成功找到<code>go.mod</code>文件，因此它正常运行:)。</p><p>还可以使用<code>go build</code>更改输出二进制文件的位置。移至<code>~/Documents/learnpackage</code>并键入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">1go build -o fintechapp<br></code></pre></td></tr></table></figure><p><code>-o</code>参数用于指定输出的二进制文件的名称。在示例中，一个名为<code>fintechapp</code>的二进制文件将会被创建。运行<code>./fintechapp</code>，二进制文件将会成功运行。</p><h3 id="导出的名称"><a href="#导出的名称" class="headerlink" title="导出的名称"></a>导出的名称</h3><p>我们在计算单利包中大写了<code>Calculate</code>函数。这在Go中有特殊意义。在go中任意大写字母开头的<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/">变量</a>或者函数都是可导出的名称。只有可导出函数和变量才在其他包中可用。在我们的示例中，我们想要在main包中使用<code>Calculate</code>函数。因此这是大写。</p><p>如果在<code>simpleinterest.go</code>中，函数名称从<code>Calculate</code>改为<code>calculete</code>，如果我们尝试在main.go中使用<code>simpleinterest.calculate(p, r, t)</code>，编译会出错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback"># learnpackage<br>./main.go:13:8: undefined: simpleinterest.calculate<br></code></pre></td></tr></table></figure><p>因此如果你想在包外使用函数，它就应该被大写。</p><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>Go的每一个包都可以有一个<code>init</code>函数。<code>init</code>函数必须不含邮任何返回类型，也不能有任何参数。init函数不能在我们的源码中被显式调用。当包被初始化的时候它会被自动调用。init函数有如下格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">func init() &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>init</code>函数可被用于执行初始化任务，也可以用来在执行开始前验证程序的正确性。</p><p>一个包的初始化顺序如下：</p><ol><li>包等级变量首先被初始化</li><li>init函数接着被调用。一个包可以有多个init函数(可以在单个文件中，也可以分布在多个文件当中)，并且它们依照出现在编译器的顺序被依次调用。</li></ol><p>如果一个包引入了其他包，被引入的包首先初始化。</p><p>如果一个包被多个包引用，它只会初始化一次。</p><p>让我们在我们的应用上做些修改，来理解<code>init</code>函数。</p><p>首先，我们在<code>simpleinterest.go</code>文件添加一个<code>init</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> simpleinterest<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * init function added</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Simple interest package initialized&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//Calculate calculates and returns the simple interest for principal p, rate of interest r for time duration t years</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(p <span class="hljs-type">float64</span>, r <span class="hljs-type">float64</span>, t <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>interest := p * (r / <span class="hljs-number">100</span>) * t<br><span class="hljs-keyword">return</span> interest<br>&#125;<br></code></pre></td></tr></table></figure><p>我们已经添加了一个简单的init函数，它只打印<code>Simple interest package initialised</code>。</p><p>现在让我们修改main包。我们知道，但计算单利的时候，本金、利率和时间期限应该比0大。我们会在<code>main.go</code>文件中使用init函数和包级别变量定义一个检查。</p><p>按如下修改<code>main.go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span> <span class="hljs-comment">//importing custom package</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> p, r, t = <span class="hljs-number">5000.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">1.0</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* init function to check if p, r and t are greater than zero</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Main package initialized&quot;</span>)<br><span class="hljs-keyword">if</span> p &lt; <span class="hljs-number">0</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;Principal is less than zero&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;Rate of interest is less than zero&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> t &lt; <span class="hljs-number">0</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;Duration is less than zero&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Simple interest calculation&quot;</span>)<br>si := simpleinterest.Calculate(p, r, t)<br>fmt.Println(<span class="hljs-string">&quot;Simple interest is&quot;</span>, si)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是对<code>main.go</code>文件所做的修改</p><ol><li><strong>p</strong>, <strong>r</strong> 和 <strong>t</strong> 从main函数级别移到了package级别。</li><li>添加了一个init函数。<em>init</em>函数打印一条日志，并通过<strong>log.Fatal</strong>在本金、利率或时间期限小于0时终止程序的运行。</li></ol><p>初始化的顺序如下，</p><ol><li>首先初始化导入的包。因此<strong>simpleinterest</strong>包首先被初始化，init方法被调用。</li><li>package级别变量<strong>p</strong>, <strong>r</strong> 和 <strong>t</strong>被初始化。</li><li>main包中的<strong>init</strong>函数被调用。</li><li><strong>main</strong>函数最后被调用。</li></ol><p>如果你运行程序，你会得到如下的输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">Simple interest <span class="hljs-keyword">package</span> initialized<br>Main <span class="hljs-keyword">package</span> initialized<br>Simple interest calculation<br>Simple interest is <span class="hljs-number">500</span><br></code></pre></td></tr></table></figure><p>正如我们所预期的，<code>simpleinterest</code>包首先被调用，接下来是package级别的变量<code>p</code>, <code>r</code> 和 <code>t</code>被初始化。main包中的init函数接着被调用，它检查<code>p</code>, <code>r</code> 和 <code>t</code>是否小于0，在条件为true的时候终止程序。我们将会在<a href="../%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/">单独的教程</a>中详细学习<code>if</code>语句。到目前为止，可以假设。<code>if p &lt; 0</code>会检查<code>p</code>是否小于0，如果它确实小于0，程序将被终止。我们已经为<code>r</code>和<code>t</code>写了类似的条件。在这个例子中，所有这些条件都是false，程序执行会继续。最后，main函数被调用。</p><p>让我们微调一下程序，学习init函数的使用。</p><p>在<code>main.go</code>中找到这一行，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">var p, r, t = 5000.0, 10.0, 1.0<br></code></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">var p, r, t = -5000.0, 10.0, 1.0<br></code></pre></td></tr></table></figure><p>我们已经把<code>p</code>初始化成了负数。</p><p>现在如果你运行程序，你会看到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">Simple interest <span class="hljs-keyword">package</span> initialized<br>Main <span class="hljs-keyword">package</span> initialized<br><span class="hljs-number">2024</span>/<span class="hljs-number">04</span>/<span class="hljs-number">01</span> <span class="hljs-number">02</span>:<span class="hljs-number">58</span>:<span class="hljs-number">32</span> Principal is less than zero<br></code></pre></td></tr></table></figure><p><em>p</em>是负数。因此当init函数运行时，程序会在打印<code>Principal is less than zero</code>后终止。</p><h3 id="空白标识符的使用"><a href="#空白标识符的使用" class="headerlink" title="空白标识符的使用"></a>空白标识符的使用</h3><p>在Go中，引入一个包但是不使用它是不合法的。如果你这么做，编译器会抱怨。原因是避免为使用的包膨胀，浙江显著增加编译时间。把<code>main.go</code>中的代码替换为如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>  <br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序将会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback"># learnpackage<br>./main.go:4:2: imported and not used: &quot;learnpackage/simpleinterest&quot;<br></code></pre></td></tr></table></figure><p>但是，当程序正在处于开发活跃状态时，导入包并稍后(如果不是现在)在代码中的某个位置使用它们是很常见的。在这些情况下，<code>_</code>空白标识符可以拯救我们。</p><p>上面的程序的错误可以被下面的代码改动所消除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>  <br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> _ = simpleinterest.Calculate<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这一行，<code>var _ = simpleinterest.Calculate</code>,屏蔽了错误。我们应该跟踪这些类型的错误消音器，并在应用程序开发结束时移除它们，包括导入的包(如果不使用的话)。因此，建议在导入语句后在package级别编写错误消音器。</p><p>有时候，我们需要导入一个包只是为了确保该包的初始化过程得以执行，即使我们并不需要在代码中使用该包的任何函数或变量。例如，我们可能需要确保 <code>simpleinterest</code> 包中的 <code>init</code> 函数被调用，即使我们并不打算在代码的任何地方使用这个包。在这种情况下，也可以使用<strong>空白标识符</strong> _ 来实现，如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>_ <span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行上述代码，程序会输出<code>Simple interest package initialized</code>。我们已经成功初始化了<code>simpleinterest</code>包，即使它没有在任何地方使用。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/">if else 语句</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GoLangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】6-函数</title>
    <link href="/%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/"/>
    <url>/%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="【GolangBot】6-函数"><a href="#【GolangBot】6-函数" class="headerlink" title="【GolangBot】6-函数"></a>【GolangBot】6-函数</h1><p>欢迎来到<a href="../GolangBot/">Golang系列教程</a>的第六篇。</p><h3 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a>什么是函数？</h3><p>函数是执行特定任务的代码块。函数接受输入，对输入执行一些操作并产生输出。例如，一个函数可以把半径作为输入然后计算出面积和周长作为输出。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>下面是Go中声明一个函数的语法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionname</span><span class="hljs-params">(parametername datatype)</span></span> returntype &#123;<br> <span class="hljs-comment">//function body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>函数声明以<code>func</code>关键字开始，后面跟着<code>functionname</code>。参数被指定在<code> (</code> 和 <code>)</code>之间，再往后是函数的<code>returntype</code>。指定参数的语法是，参数类型跟在参数名字后面。任何数量的参数都是可以的，比如：<code>(parameter1 datatype, parameter2 datatype)</code>。然后在<code>&#123;</code> 和 <code>&#125;</code>之间有一个代码块，这是函数体。</p><p>参数和返回值类型在一个函数中都是可选项。因此下面的函数声明也是符合规定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionname</span><span class="hljs-params">()</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a>示例函数</h3><p>我们来写一个函数，把产品单价和数量作为输入参数，返回这两个值的乘积作为总价。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateBill</span><span class="hljs-params">(price <span class="hljs-type">int</span>, quantity <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> totalPrice = price * quantity<br><span class="hljs-keyword">return</span> totalPrice<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的函数有两个<code>int</code>类型的输入参数<code>price</code>和<code>quantity</code>，它返回<code>totalPrice</code>，这是<code>price</code>和<code>quantity</code>的乘积。返回值也是<code>int</code>类型。</p><p><strong>如果连着的几个参数是同一种类型，我们可以省去每次都写类型的麻烦，只在最后写一个类型就够了，即<code>price int, quantity int</code> 可以写成<code>price, quantity int</code>。</strong>上面的函数因此可以重写为，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateBill</span><span class="hljs-params">(price, quantity <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> totalPrice = price * quantity<br><span class="hljs-keyword">return</span> totalPrice<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们有一个函数就虚了，让我们从代码里的某些地方来调用它。调用函数的语法是<code>functionname(parameters)</code>。上面的函数可以用这个代码调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">calculateBill(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>这是我们用上面的函数打印总价的完整程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateBill</span><span class="hljs-params">(price, quantity <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> totalPrice = price * quantity<br><span class="hljs-keyword">return</span> totalPrice<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>price, quantity := <span class="hljs-number">90</span>, <span class="hljs-number">6</span><br>totalPrice := calculateBill(price, quantity)<br>fmt.Println(<span class="hljs-string">&quot;Total price is&quot;</span>, totalPrice)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/07SsuF0MpDP">Run in playground</a></p><p>上面的程序将会打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Total price is 540<br></code></pre></td></tr></table></figure><h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><p>一个函数返回多个值这种情况也是可能的。让我们写一个函数<code>rectProps</code>，它接受一个矩形的<code>length</code>(长)和<code>width</code>(宽)，返回矩形的<code>area</code>(面积)和<code>perimeter</code>(周长)。举行的面积是长和宽的乘积，周长是长宽之和的两倍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rectProps</span><span class="hljs-params">(length, width <span class="hljs-type">float64</span>)</span></span>(<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>) &#123;<br><span class="hljs-keyword">var</span> area = length * width<br><span class="hljs-keyword">var</span> perimeter = (length + width) * <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> area, perimeter<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> area, perimeter := rectProps(<span class="hljs-number">10.8</span>, <span class="hljs-number">5.6</span>)<br>fmt.Printf(<span class="hljs-string">&quot;Area %f Perimeter %f&quot;</span>, area, perimeter)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/wlUbh-WyOKt">Run in playground</a></p><p>如果一个函数返回多个值，那他们必须被再<code>(</code> 和 <code>)</code>之间被指定。<code>func rectProps(length, width float64)(float64, float64)</code>有两个float64类型的参数<code>length</code>和<code>width</code>，并且返回两个<code>float64</code>类型的值。上面的程序打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Area 60.480000 Perimeter 32.800000<br></code></pre></td></tr></table></figure><h3 id="为返回值命名"><a href="#为返回值命名" class="headerlink" title="为返回值命名"></a>为返回值命名</h3><p>从函数中返回一个命名好的值也是可以的。如果返回值被命名，它可以被视为函数第一行的变量。</p><p>上面的rectProps可以用命名返回值重写为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rectProps</span><span class="hljs-params">(length, width <span class="hljs-type">float64</span>)</span></span>(area, perimeter <span class="hljs-type">float64</span>) &#123;  <br>    area = length * width<br>    perimeter = (length + width) * <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">//no explicit return value</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>area</strong>和<strong>perimeter</strong>在上面的函数中是被命名的返回值。请注意，函数的返回语句没有显式地返回任何值。因为<code>area</code>和<code>perimeter</code>在函数声明中被指定为返回值，所以当运行到返回语句的时候它们被自动返回了。</p><h3 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h3><p><strong>_</strong> 在Go中是空白标识符。它可以用于代替任何类型的任何值。让我们看看这个空白标识符的作用是什么。</p><p>函数<code>rectProps</code>返回矩形的面积和周长。如果我们只需要<code>area</code>并且想要抛掉<code>perimeter</code>该怎么办呢？这就是<code>_</code>的作用场景。</p><p>下面的程序只使用了<code>rectProps</code>函数返回的<code>area</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rectProps</span><span class="hljs-params">(length, width <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>) &#123;<br><span class="hljs-keyword">var</span> area = length * width<br><span class="hljs-keyword">var</span> perimeter = (length + width) * <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> area, perimeter<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>area, _ := rectProps(<span class="hljs-number">10.8</span>, <span class="hljs-number">5.6</span>) <span class="hljs-comment">// perimeter is discarded</span><br>fmt.Printf(<span class="hljs-string">&quot;Area %f &quot;</span>, area)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/Tw6KYjo5zoI">Run in playground</a></p><p>在第13行，我们只用了<code>area</code>，而<code>_</code>标识符用于抛掉<code>perimeter</code>。</p><p><strong>下一篇教程 - <a href="../_GolangBot%E3%80%917-%E5%8C%85/">包</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GoLangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】5-常量</title>
    <link href="/%E3%80%90GolangBot%E3%80%915-%E5%B8%B8%E9%87%8F/"/>
    <url>/%E3%80%90GolangBot%E3%80%915-%E5%B8%B8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我们<a href="../golangbot/">Golang系列教程</a>的第五篇。</p><h3 id="什么是常量？"><a href="#什么是常量？" class="headerlink" title="什么是常量？"></a>什么是常量？</h3><p>Go中的常量用于定义固定的值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fallback">95 <br>&quot;I love Go&quot; <br>67.89 <br></code></pre></td></tr></table></figure><p>等等。常量通常用来表示一个值，这个值在应用的整个生命周期中都不会改变。</p><h3 id="声明一个常量"><a href="#声明一个常量" class="headerlink" title="声明一个常量"></a>声明一个常量</h3><p>关键字<code>const</code>在Go中用来声明一个常量。我们用一个例子来看看如何声明一个常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">50</span><br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/mv3B-q3h0zh">Run in playground</a></p><p>在上面的代码中，<code>a</code>是一个常量，它被赋值为<code>50</code>。</p><h3 id="定义一组常量"><a href="#定义一组常量" class="headerlink" title="定义一组常量"></a>定义一组常量</h3><p>Go中也有语法用于使用一条语句声明一组常量。下面是用这个语法来声明一组常量的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>retryLimit = <span class="hljs-number">4</span><br>httpMethod = <span class="hljs-string">&quot;GET&quot;</span><br>)<br><br>fmt.Println(retryLimit)<br>fmt.Println(httpMethod)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/gSPJC0y49Sm">Run in playground</a></p><p>在上面的程序中，我们已经定义了2个常量<code>retryLimit</code>和<code>httpMethod</code>。上面的程序将会打印，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">4<br>GET<br></code></pre></td></tr></table></figure><p>常量，顾名思义，不能被再赋值为其他值。在上面的程序中，我们尝试为<code>a</code>赋值另一个值<code>89</code>。因为<code>a</code>是一个常量，所以这是不允许的。这个程序将会运行失败，报错<code>cannot assign to a (neither addressable nor a map index expression)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">const</span> a = <span class="hljs-number">55</span> <span class="hljs-comment">//allowed</span><br>    a = <span class="hljs-number">89</span> <span class="hljs-comment">//reassignment not allowed</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/5ggPss1iSsl">Run in playground</a></p><p><strong>常量的值应该在编译时就已经知道了。</strong>因此，它不能被赋值为<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数调用</a>的值，因为函数调用发生在运行时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = math.Sqrt(<span class="hljs-number">4</span>) <span class="hljs-comment">//allowed</span><br>fmt.Println(a)<br><span class="hljs-keyword">const</span> b = math.Sqrt(<span class="hljs-number">4</span>) <span class="hljs-comment">//not allowed</span><br>fmt.Println(b)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/fFLfoN0L3Nf">Run in playground</a></p><p>在上面的程序中，<code>a</code>是一个<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/">变量</a>，因此它可以被赋值为函数<code>math.Sqrt(4)</code>的结果（我们将在<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">单独的教程</a>中讨论函数）。</p><p><code>b</code>是一个常量，并且<code>b</code>的值需要在编译时就知道。函数<code>math.Sqrt(4)</code>仅在运行时求值，因此<code>const b = math.Sqrt(4)</code>编译失败，出现错误，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">./prog.go:11:12: math.Sqrt(4) (value of type float64) is not constant<br></code></pre></td></tr></table></figure><h3 id="字符串常量、类型常量和无类型常量"><a href="#字符串常量、类型常量和无类型常量" class="headerlink" title="字符串常量、类型常量和无类型常量"></a>字符串常量、类型常量和无类型常量</h3><p>在Go中任何被双引号包起来的值都是一个字符串常量。例如，像<code>&quot;Hello World&quot;</code>,<code>&quot;Sam&quot;</code>在Go中都是常量。</p><p>一个字符串常量属于什么类型？答案是<strong>无类型。</strong></p><p><strong>一个像”Hello World”的字符串没有任何类型。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> hello = <span class="hljs-string">&quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>在上面这行代码中，常量<code>hello</code>没有任何类型。</p><p>Go是强类型语言。所有变量都需要显式的类型。下面的程序中，为变量<code>name</code>赋值无类型的常量<code>n</code>会发生什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> n = <span class="hljs-string">&quot;Sam&quot;</span><br><span class="hljs-keyword">var</span> name = n<br>fmt.Printf(<span class="hljs-string">&quot;type %T value %v&quot;</span>, name, name)<br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/CFqbC8yfe6C">Run in playground</a></p><p><strong>答案是无类型常量有一个与之关联的默认类型，只有在某行代码需要时才会提供默认类型。在第9行的语句<code>var name = n</code>中，<code>name</code>需要一个类型，它从<code>string</code>常量<code>n</code>的默认类型中获取</strong></p><p>有没有一种办法可以创建一个<strong>类型常量</strong>？答案是有的。下面的代码创建了一个类型常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><p><em>name</em> 在上面的代码中是一个<code>string</code>类型的常量。</p><p>Go is a strongly typed language. Mixing types during the assignment is not allowed. Let’s see what this means with the help of a program.</p><p>Go是强类型语言。赋值过程中是不允许混合类型的。我们用一个程序来看看这是啥意思。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> defaultName = <span class="hljs-string">&quot;Sam&quot;</span> <span class="hljs-comment">//allowed</span><br><span class="hljs-keyword">type</span> myString <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> customName myString = <span class="hljs-string">&quot;Sam&quot;</span> <span class="hljs-comment">//allowed</span><br>customName = defaultName        <span class="hljs-comment">//not allowed</span><br>fmt.Println(customName)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/sJ1rCtzebkP">Run in playground</a></p><p>在上面的代码中，我们首先创建了一个变量<code>defaultName</code>，并将常量<code>Sam</code>赋值给他。<strong>常量<code>Sam</code>的默认类型是<code>string</code>，所以在赋值之后，<code>defaultName</code>的类型是<code>string</code>。</strong></p><p>在下一行，我们创建了一个新的类型<code>myString</code>，这是<code>string</code>类型的别称。</p><p>然后我们创建一个<code>myString</code>类型的变量<code>customName</code>，并且将常量<code>Sam</code>赋值给它。因为常量<code>Sam</code>是无类型的，它可以被赋值给任意<code>string</code>类型的变量。因此这个赋值操作是允许的，<code>customName</code>得到类型<code>myString</code>。</p><p>现在我们有一个<code>string</code>类型的变量<code>defalutName</code>，另一个<code>myString</code>类型的变量<code>customName</code>。尽管我们知道<code>myString</code>是<code>string</code>的别名，Go的强类型规则不允许将一种类型的值赋值给另外一种类型。<strong>因此赋值操作<code>customName = defaultName</code>是不被允许的，编译操作会抛出一个错误：<code>./prog.go:9:15: cannot use defaultName (variable of type string) as myString value in assignment</code></strong></p><p>为了让上面的程序正常工作，<code>defalutName</code>必须被转换为<code>myString</code>类型。这在下面的程序中的第9行进行操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> defaultName = <span class="hljs-string">&quot;Sam&quot;</span> <span class="hljs-comment">//allowed</span><br><span class="hljs-keyword">type</span> myString <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> customName myString = <span class="hljs-string">&quot;Sam&quot;</span>    <span class="hljs-comment">//allowed</span><br>customName = myString(defaultName) <span class="hljs-comment">//allowed</span><br>fmt.Println(customName)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/EObC2BTq4KW">Run in playground</a></p><p>上面的程序将会打印<code>Sam</code>。</p><h3 id="布尔型常量"><a href="#布尔型常量" class="headerlink" title="布尔型常量"></a>布尔型常量</h3><p>布尔型常量和字符串常量没有什么区别。它们是两个无类型的常量<code>true</code>和<code>false</code>。字符串常量的规则对于布尔型常量也同样适用，所以我们就不再赘述了。下面是一个简单的程序来解释布尔型常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> trueConst = <span class="hljs-literal">true</span><br><span class="hljs-keyword">type</span> myBool <span class="hljs-type">bool</span><br><span class="hljs-keyword">var</span> defaultBool = trueConst <span class="hljs-comment">//allowed</span><br><span class="hljs-keyword">var</span> customBool myBool = trueConst <span class="hljs-comment">//allowed</span><br>defaultBool = customBool <span class="hljs-comment">//not allowed</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/YWZ80x94Q1D">Run in playground</a></p><p>The above program is self-explanatory.</p><p>上面的程序是不言自明的。</p><h3 id="数字常量"><a href="#数字常量" class="headerlink" title="数字常量"></a>数字常量</h3><p>数字常量包括整数、浮点数和复数。数字常量有一些细节需要注意。</p><p>让我们举一些例子来说明问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> c = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> intVar <span class="hljs-type">int</span> = c<br><span class="hljs-keyword">var</span> int32Var <span class="hljs-type">int32</span> = c<br><span class="hljs-keyword">var</span> float64Var <span class="hljs-type">float64</span> = c<br><span class="hljs-keyword">var</span> complex64Var <span class="hljs-type">complex64</span> = c<br>fmt.Println(<span class="hljs-string">&quot;intVar&quot;</span>, intVar, <span class="hljs-string">&quot;\nint32Var&quot;</span>, int32Var, <span class="hljs-string">&quot;\nfloat64Var&quot;</span>, float64Var, <span class="hljs-string">&quot;\ncomplex64Var&quot;</span>, complex64Var)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/9MzdS-nmA1Z">Run in playground</a></p><p>在上面的程序中，常量<code>c</code>是<code>untyped</code>类型并且有一个值<code>5</code>。<strong>你也许想知道c的默认类型是什么，以及如果它确实有默认类型，我们又该如何将其赋值给其他不同类型的变量。</strong>答案就在<code>c</code>的语法当中。下面的程序将会让这个问题更加清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-number">5.6</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-number">5</span> + <span class="hljs-number">6i</span><br>fmt.Printf(<span class="hljs-string">&quot;i&#x27;s type is %T, f&#x27;s type is %T, c&#x27;s type is %T&quot;</span>, i, f, c)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/XVEGb9aUsxs">Run in playground</a></p><p>在上面的程序中，每个变量的类型都被数字常量的语法所定义。根据语法，<strong>5</strong>是一个整数，<strong>5.6</strong>是一个浮点数，<strong>5 + 6i</strong>是一个复数。上面的程序运行会打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">i&#x27;s type is int, f&#x27;s type is float64, c&#x27;s type is complex128<br></code></pre></td></tr></table></figure><p>知道了这些，我们来试着理解下面的程序会如何工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> c = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> intVar <span class="hljs-type">int</span> = c<br><span class="hljs-keyword">var</span> int32Var <span class="hljs-type">int32</span> = c<br><span class="hljs-keyword">var</span> float64Var <span class="hljs-type">float64</span> = c<br><span class="hljs-keyword">var</span> complex64Var <span class="hljs-type">complex64</span> = c<br>fmt.Println(<span class="hljs-string">&quot;intVar&quot;</span>, intVar, <span class="hljs-string">&quot;\nint32Var&quot;</span>, int32Var, <span class="hljs-string">&quot;\nfloat64Var&quot;</span>, float64Var, <span class="hljs-string">&quot;\ncomplex64Var&quot;</span>, complex64Var)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/9MzdS-nmA1Z">Run in playground</a></p><p>在上面的程序中，<code>c</code>的值是<code>5</code>并且<code>c</code>的语法是通用语法。它可以表示浮点数、整数，甚至是无虚部复数。因此它可以赋值给任意兼容类型。可以认为，这些类型的常量的默认类型是由它们所使用的上下文生成的。<code>var intVar int = c</code>需要<code>c</code>是<code>int</code>类型，所以它变成了一个<code>int</code>常量。<code>var complex64Var complex64 = c</code>需要<code>c</code>是复数类型，因此它变成一个复数常量。以此类推:)。</p><h3 id="数字表达式"><a href="#数字表达式" class="headerlink" title="数字表达式"></a>数字表达式</h3><p>数字常量可以在表达式中自由混合和匹配，只有当它们赋值给变量或者用于需要类型的代码中才需要类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">5.9</span> / <span class="hljs-number">8</span><br>fmt.Printf(<span class="hljs-string">&quot;a&#x27;s type is %T and value is %v&quot;</span>, a, a)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/Nsak9scUAWg">Run in playground</a></p><p>在上面的程序中，<code>5.9</code>语法上是一个浮点数，<code>8</code>语法上是一个整数。不过，由于两者都是数字常量，因此<code>5.9/8</code>是被允许的。相除后的结果是<code>0.7375</code>是一个浮点数<code>float</code>。程序的输出是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">a&#x27;s type is float64 and value is 0.7375<br></code></pre></td></tr></table></figure><p><strong>下一篇教程 - <a href="../_posts/%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GoLangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】4-数据类型</title>
    <link href="/%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="【GolangBot】4-数据类型"><a href="#【GolangBot】4-数据类型" class="headerlink" title="【GolangBot】4-数据类型"></a>【GolangBot】4-数据类型</h1><p>这是我们<a href="../golangbot/">Golang系列教程</a>的第四篇.</p><p>请阅读<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/">第三部分：变量</a>来学习变量。</p><p>下面是Go中可用的基本类型。</p><ul><li>bool</li><li>Numeric Types<ul><li>int8, int16, int32, int64, int</li><li>uint8, uint16, uint32, uint64, uint</li><li>float32, float64</li><li>complex64, complex128</li><li>byte</li><li>rune</li></ul></li><li>string</li></ul><h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p><code>bool</code>类型表示布尔值。它要么是<code>true</code>要么是<code>false</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := <span class="hljs-literal">true</span><br>    b := <span class="hljs-literal">false</span><br>    fmt.Println(<span class="hljs-string">&quot;a:&quot;</span>, a, <span class="hljs-string">&quot;b:&quot;</span>, b)<br>    c := a &amp;&amp; b<br>    fmt.Println(<span class="hljs-string">&quot;c:&quot;</span>, c)<br>    d := a || b<br>    fmt.Println(<span class="hljs-string">&quot;d:&quot;</span>, d)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/v_W3HQ0MdY">Run in playground</a></p><p>在上面的程序中，a被分配了<code>true</code>,b被分配了<code>false</code>。</p><p><code>&amp;&amp;</code>是一个布尔操作符，当两个操作数都为true的时候才返回true。</p><p>c被分配了值<code>a &amp;&amp; b</code>。在这个示例中，<code>c</code>是<code>false</code>，因为<code>a</code>和<code>b</code>不都为<code>true</code>。</p><p><code>||</code>操作符当<code>a</code>或<code>b</code>有一个为<code>true</code>的时候返回true。在这个示例中，<code>d</code>为<code>true</code>，因为<code>a</code>是true。这个程序我们将会得到下面的输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fallback">a: true b: false<br>c: false<br>d: true<br></code></pre></td></tr></table></figure><h3 id="带符号整数"><a href="#带符号整数" class="headerlink" title="带符号整数"></a>带符号整数</h3><p>下面是在go中可用的带符号整数数据类型。</p><table><thead><tr><th>数据类型</th><th>描述</th><th>大小</th><th>范围</th></tr></thead><tbody><tr><td>int8</td><td>8 bit 带符号整数</td><td>8 bits</td><td>-128 to 127</td></tr><tr><td>int16</td><td>16 bit 带符号整数</td><td>16 bits</td><td>-32768 to 32767</td></tr><tr><td>int32</td><td>32 bit 带符号整数</td><td>32 bits</td><td>-2147483648 to 2147483647</td></tr><tr><td>int64</td><td>64 bit 带符号整数</td><td>64 bits</td><td>-9223372036854775808 to 9223372036854775807</td></tr><tr><td>int</td><td>表示32bit或64bit整数，取决于底层架构。通常应该用<code>int</code>表示整数，除非有需要使用特定大小的整数。</td><td>32位系统中 32 bits ，64位系统中64 bits .</td><td>在32位系统中：-2147483648 to 2147483647  <br />在64位系统中：<br />-9223372036854775808 to 9223372036854775807</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">89</span><br>b := <span class="hljs-number">95</span><br>fmt.Println(<span class="hljs-string">&quot;value of a is&quot;</span>, a, <span class="hljs-string">&quot;and b is&quot;</span>, b)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/Up5vcjHyunS">Run in playground</a></p><p>上面的程序将会打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">value of a is 89 and b is 95<br></code></pre></td></tr></table></figure><p>在上面的程序中，<code>a</code>是<code>int</code>类型，<code>b</code>的类型是根据分配给它的值(95)推断出来的。如上所述，int的尺寸是<em>32位系统中 32 bits ，64位系统中64 bits</em>。让我们继续验证这个说法。</p><p>一个变量的类型可以使用<code>Printf</code>函数中的<code>%T</code>格式指定符来打印出来。Go有一个<a href="https://pkg.go.dev/unsafe">unsafe</a>包，其中有一个<a href="https://pkg.go.dev/unsafe#Sizeof">Sizeof</a>函数，它可以返回以字节为单位的变量大小。<em>unsafe</em>包应该谨慎使用，因为它可能存在可移植性问题。但出于教程目的，我们可以使用它。</p><p>下面的程序输出了变量<code>a</code>和<code>b</code>的类型和大小。<code>%T</code>是一个格式指定符用来打印类型，<code>%d</code>用来打印大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">89</span><br>b := <span class="hljs-number">95</span><br>fmt.Println(<span class="hljs-string">&quot;value of a is&quot;</span>, a, <span class="hljs-string">&quot;and b is&quot;</span>, b)<br>fmt.Printf(<span class="hljs-string">&quot;type of a is %T, size of a is %d bytes&quot;</span>, a, unsafe.Sizeof(a))   <span class="hljs-comment">//type and size of a</span><br>fmt.Printf(<span class="hljs-string">&quot;\ntype of b is %T, size of b is %d bytes&quot;</span>, b, unsafe.Sizeof(b)) <span class="hljs-comment">//type and size of b</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/fAIGqDZGm7C">Run in playground</a></p><p>上面的程序将会打印如下输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fallback">value of a is 89 and b is 95<br>type of a is int, size of a is 8 bytes<br>type of b is int, size of b is 8 bytes<br></code></pre></td></tr></table></figure><p>我们可以从上面的输出中推断出<code>a</code>和<code>b</code>都是<code>int</code>类型，并且它们有8字节大小(64bits)。当你在32位系统运行上述程序时，结果会有所不同。在32位系统，a和b占4字节(32bits)。</p><h3 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h3><p>顾名思义，无符号整数只能用于存储正整数。以下是Go中可用的无符号整数数据类型。</p><table><thead><tr><th>数据类型</th><th>描述</th><th>大小</th><th>范围</th></tr></thead><tbody><tr><td>uint8</td><td>8 bit 无符号整数</td><td>8 bits</td><td>0 to 255</td></tr><tr><td>uint16</td><td>16 bit 无符号整数</td><td>16 bits</td><td>0 to 65535</td></tr><tr><td>uint32</td><td>32 bit 无符号整数</td><td>32 bits</td><td>0 to 4294967295</td></tr><tr><td>uint64</td><td>64 bit 无符号整数</td><td>64 bits</td><td>0 to 18446744073709551615</td></tr><tr><td>uint</td><td>取决于底层架构，32 or 64 bit 无符号整数</td><td>32位系统上32 bits;64位系统上64 bits</td><td>0 to 4294967295 in 32 bit systems and 0 to 18446744073709551615 in 64 bit systems</td></tr></tbody></table><p>无符号整数用于不需要使用负数的场景。</p><p>在下面的程序中，变量<code>a</code>和<code>b</code>是<code>uint</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">uint</span> = <span class="hljs-number">60</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">uint</span> = <span class="hljs-number">30</span><br>c := a * b<br>fmt.Println(<span class="hljs-string">&quot;c =&quot;</span>, c)<br>fmt.Printf(<span class="hljs-string">&quot;Data type of variable c is %T&quot;</span>, c)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/5CKH28Wl_k6">Run in playground</a></p><p>上面的程序打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">1c = 1800<br>2Data type of variable c is uint<br></code></pre></td></tr></table></figure><p>因为<code>a</code>和<code>b</code>都是<code>uint</code>类型，所以推断<code>c</code>的类型也是<code>uint</code>。</p><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><table><thead><tr><th>数据类型</th><th>Description</th></tr></thead><tbody><tr><td>float32</td><td>32 bit 浮点数</td></tr><tr><td>float64</td><td>64 bit 浮点数</td></tr></tbody></table><p>下面是一个简单的程序，用来说明整数和浮点数类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a, b := <span class="hljs-number">5.67</span>, <span class="hljs-number">8.97</span><br>fmt.Printf(<span class="hljs-string">&quot;type of a %T b %T\n&quot;</span>, a, b)<br>sum := a + b<br>diff := a - b<br>fmt.Printf(<span class="hljs-string">&quot;sum of %f and %f is %f, diff is %f\n&quot;</span>, a, b, sum, diff)<br><br>no1, no2 := <span class="hljs-number">56</span>, <span class="hljs-number">89</span><br>fmt.Printf(<span class="hljs-string">&quot;type of no1 %T no2 %T\n&quot;</span>, no1, no2)<br>fmt.Printf(<span class="hljs-string">&quot;sum of %d and %d is %d, diff is %d&quot;</span>, no1, no2, no1+no2, no1-no2)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/ST637417mye">Run in playground</a></p><p><code>a</code>和<code>b</code>的类型是从分配给它们的值推断出来的。在这个例子里面，<code>a</code>和<code>b</code>是<code>float64</code>类型。<code>float64</code>是浮点值的默认类型。我们把<code>a</code>和<code>b</code>相加，然后把结果分配给变量<code>sum</code>。我们用<code>a</code>减去<code>b</code>，然后把结果分配给变量<code>diff</code>。把<code>sum</code>和<code>diff</code>打印出来。相似的计算在<code>no1</code>和<code>no2</code>中进行。上面的程序将会打印,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fallback">type of a float64 b float64<br>sum of 5.670000 and 8.970000 is 14.640000, diff is -3.300000<br>type of no1 int no2 int<br>sum of 56 and 89 is 145, diff is -33<br></code></pre></td></tr></table></figure><h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>complex64</td><td>具有float32类型的实部和虚部的复数</td></tr><tr><td>complex128</td><td>具有float64类型的实部和虚部的复数</td></tr></tbody></table><p>标准库函数**<a href="https://pkg.go.dev/builtin#complex">complex</a>**用于构建具有实部和虚部的复数。complex函数具有如下定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">func complex(r, i FloatType) ComplexType<br></code></pre></td></tr></table></figure><p>它将实部和虚部作为参数并返回复数类型。<em>实部和虚部必须是相同的数据类型，即float32或float64。如果实部和虚部都是float32，函数将返回complex64类型的复数值。如果实部和虚部都是float64，则此函数返回complex128类型的复数值。</em></p><p>复数类型也可以使用短语法创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">c := 6 + 7i<br></code></pre></td></tr></table></figure><p>让我们写一个小程序来理解复数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := <span class="hljs-built_in">complex</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>)<br>c2 := <span class="hljs-number">8</span> + <span class="hljs-number">27i</span><br>cadd := c1 + c2<br>fmt.Println(<span class="hljs-string">&quot;sum:&quot;</span>, cadd)<br>cmul := c1 * c2<br>fmt.Println(<span class="hljs-string">&quot;product:&quot;</span>, cmul)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/-d_Y_medfSb">Run in playground</a></p><p>在上面的程序中，c1和c2是两个复数。c1有5作为实部，7作为虚部。c2有8作为实部，27作为虚部。<code>cadd</code>被指定为c1和c2的和，<code>cmul</code>被指定为c1和c2的乘积。这个程序将会输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">sum: (13+34i)<br>product: (-149+191i)<br></code></pre></td></tr></table></figure><h3 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h3><p><strong>byte</strong> 是uint8的别名。<br><strong>rune</strong> 是int32的别名。</p><p>我们将会在学习<a href="../%E3%80%90GolangBot%E3%80%9114-Strings/">strings</a>的时候详细讨论bytes和runes。</p><h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><p>Strings在Go中是bytes的集合。如果这个定义没有任何意义也没有关系。现在，我们可以假定字符串是字符的集合。我们将在单独的<a href="../%E3%80%90GolangBot%E3%80%9114-Strings/">strings教程</a>中详细了解字符串。</p><p>让我们用字符串写一个程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>first := <span class="hljs-string">&quot;Naveen&quot;</span><br>last := <span class="hljs-string">&quot;Ramanathan&quot;</span><br>name := first +<span class="hljs-string">&quot; &quot;</span>+ last<br>fmt.Println(<span class="hljs-string">&quot;My name is&quot;</span>,name)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/kYnedsD6OmN">Run in playground</a></p><p>在上面的程序中，<code>first</code>被指定为字符串<code>Naveen</code>，<code>last</code>被指定为字符串<code>Ramanathan</code>。可以使用<code>+</code>运算符连接字符串。<code>name</code>的值为<code>first</code>，后加空格，最后加<code>last</code>。上述程序将打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">1My name is Naveen Ramanathan<br></code></pre></td></tr></table></figure><p>作为输出结果。</p><p>还可以对字符串执行更多操作。我们将在单独的教程中讨论这些内容。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go对于显式输入非常严格。没有自动类型提升或者转换。让我们用一个例子来看一下这是什么意思。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">80</span>      <span class="hljs-comment">//int</span><br>b := <span class="hljs-number">91.8</span>    <span class="hljs-comment">//float64</span><br>sum := a + b <span class="hljs-comment">//int + float64 not allowed</span><br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/Fo537OgUC2B">Run in playground</a></p><p>上面的代码在C语言中是完全合法的，但在<code>Go</code>当中，这个程序无法编译。<code>a</code>是一个<code>int</code>类型的变量，<code>b</code>是一个<code>float64</code>类型的变量。我们尝试将两个不同类型的数字相加，这是不允许的。当你运行这个程序，你将会看到如下的编译错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">1./prog.go:10:9: invalid operation: a + b (mismatched types int and float64)<br></code></pre></td></tr></table></figure><p>To fix the error, both <code>a</code> and <code>b</code> must be of the same type. Let’s convert <code>b</code> to <code>int</code>. <em>T(v) is the syntax to convert a value v to type T</em></p><p>为了修复这个错误，<code>a</code>和<code>b</code>必须是相同类型。让我们把<code>b</code>转换为<code>int</code>。<em>T(v) 是将值v转换为T类型的语法</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">80</span>           <span class="hljs-comment">//int</span><br>b := <span class="hljs-number">91.8</span>         <span class="hljs-comment">//float64</span><br>sum := a + <span class="hljs-type">int</span>(b) <span class="hljs-comment">//int + float64 not allowed</span><br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/Yc00DWzrYl8">Run in playground</a></p><p>因为<code>b</code>从<code>float</code>被转换为了<code>int</code>，它的浮点值将会被截断，因此我们将会看到<code>171</code>作为输出。</p><p>赋值的情况也是如此。奖一种类型的变量赋值给另一种类型的变量时，需要进行显式类型转换。下面的程序对此进行了解释。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> j <span class="hljs-type">float64</span> = <span class="hljs-type">float64</span>(i) <span class="hljs-comment">//this statement will not work without explicit conversion</span><br>fmt.Println(<span class="hljs-string">&quot;j =&quot;</span>, j)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/Dia3qOrRi_j">Run in playground</a></p><p>在第9行,<code>i</code>被转换为了<code>float64</code>，然后赋值给了<code>j</code>。但你尝试在不进行类型转换的情况下，将<code>i</code>赋值给<code>j</code>时，编译器将会抛出一个错误。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%915-%E5%B8%B8%E9%87%8F/">常量</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GoLangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】3-变量</title>
    <link href="/%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/"/>
    <url>/%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="【GolangBot】3-变量"><a href="#【GolangBot】3-变量" class="headerlink" title="【GolangBot】3-变量"></a>【GolangBot】3-变量</h1><p>这是我们<a href="../golangbot/">Golang系列教程</a>的第三篇，这篇我们来处理Golang中的变量。</p><p>你可以阅读<a href="../%E3%80%90GolangBot%E3%80%912-Hello-World/">第二部分</a>来学习配置Go，运行Hello World程序。</p><h3 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h3><p>变量是给内存位置的名称，用来存储特定<a href="../%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">类型</a>的值。Go中有多种语法来声明变量。我们来逐一查看。</p><h3 id="声明单个变量"><a href="#声明单个变量" class="headerlink" title="声明单个变量"></a>声明单个变量</h3><p><strong>var name type</strong> 是声明单个变量的语法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-type">int</span> <span class="hljs-comment">// variable declaration</span><br>fmt.Println(<span class="hljs-string">&quot;My initial age is&quot;</span>, age)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/5sC9oz7j_lR">Run in playground</a></p><p><code>var age int</code>语法定义了一个名为<code>age</code>，类型为<code>int</code>的变量。我们还没有给这个变量分配任何值。如果一个没有被分配任何值，Go会自动用变量类型的零值来为它赋值。在这个例子中，age被分配值为0，0是<code>int</code>类型的零值。如果你运行这个程序，你会看到如下输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">My initial age is 0  <br></code></pre></td></tr></table></figure><p>一个变量可以被分配它类型的任意值。在上面的程序中，<code>age</code>可以被分配任意的整型值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-type">int</span> <span class="hljs-comment">// variable declaration</span><br>fmt.Println(<span class="hljs-string">&quot;My initial age is&quot;</span>, age)<br>age = <span class="hljs-number">29</span> <span class="hljs-comment">//assignment</span><br>fmt.Println(<span class="hljs-string">&quot;My age after first assignment is&quot;</span>, age)<br>age = <span class="hljs-number">54</span> <span class="hljs-comment">//assignment</span><br>fmt.Println(<span class="hljs-string">&quot;My age after second assignment is&quot;</span>, age)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/6olrLC2kBTB">Run in playground</a></p><p>上面的程序将会打印如下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fallback">My initial age is 0<br>My age after first assignment is 29<br>My age after second assignment is 54<br></code></pre></td></tr></table></figure><h3 id="声明一个带初始值的变量"><a href="#声明一个带初始值的变量" class="headerlink" title="声明一个带初始值的变量"></a>声明一个带初始值的变量</h3><p>当一个变量被声明时，也可以初始化一个值。下面是声明一个带初始值的变量的语法。</p><p>A variable can also be initialized with a value when it is declared. The following is the syntax to declare a variable with an initial value.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">type</span> = initialvalue<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-type">int</span> = <span class="hljs-number">29</span> <span class="hljs-comment">// variable declaration with initial value</span><br><br>fmt.Println(<span class="hljs-string">&quot;My initial age is&quot;</span>, age)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/17Py5gyLc87">Run in playground</a></p><p>在上面的程序中，<code>age</code>是一个<code>int</code>型变量，有初始值<code>29</code>。上面的程序会打印如下输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">My initial age is 29 <br></code></pre></td></tr></table></figure><p>这证实了age已被初始化为值29.</p><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>如果一个变量有一个初始值，Go能够自动根据初始值推断出该变量的类型。因此如果变量有一个初始值，变量声明中的<code>type</code>就可以去掉。</p><p>如果变量是用下面的语法声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">var name = initialvalue<br></code></pre></td></tr></table></figure><p>Go会自动从初始值推断出变量的类型。</p><p>在下面的例子中，我们可以看到第6行变量<code>age</code>的类型<code>int</code>已经被去掉了。因为变量有一个初始值<code>29</code>，Go可以推断出它是<code>int</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age = <span class="hljs-number">29</span> <span class="hljs-comment">// type will be inferred</span><br>fmt.Println(<span class="hljs-string">&quot;My initial age is&quot;</span>, age)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/3ybtHsu6uLk">Run in playground</a></p><h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><p>多个变量可以用一条语句进行声明。</p><p><strong>var name1, name2 type &#x3D; initialvalue1, initialvalue2</strong> 是多变量声明的语法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> price, quantity <span class="hljs-type">int</span> = <span class="hljs-number">5000</span>, <span class="hljs-number">100</span> <span class="hljs-comment">//declaring multiple variables</span><br><br>fmt.Println(<span class="hljs-string">&quot;price is&quot;</span>, price, <span class="hljs-string">&quot;quantity is&quot;</span>, quantity)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/ik6-iRcjggI">Run in playground</a></p><p>如果变量有初始值，类型可以去掉。因为上面的程序中，变量有初始值，类型<code>int</code>可以去掉。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> price, quantity = <span class="hljs-number">5000</span>, <span class="hljs-number">100</span> <span class="hljs-comment">//declaring multiple variables with type inference</span><br><br>fmt.Println(<span class="hljs-string">&quot;price is&quot;</span>, price, <span class="hljs-string">&quot;quantity is&quot;</span>, quantity)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/cwD5TmYG2Nf">Run in playground</a></p><p>上面的程序将会打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">price is 5000 quantity is 100<br></code></pre></td></tr></table></figure><p>现在也许你已经猜到了，如果初始值未指定<code>price</code>和<code>quanlity</code>的初始值，它们的初始值将是<code>0</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> price, quantity <span class="hljs-type">int</span><br>fmt.Println(<span class="hljs-string">&quot;price is&quot;</span>, price, <span class="hljs-string">&quot;quantity is&quot;</span>, quantity)<br>price = <span class="hljs-number">3000</span><br>quantity = <span class="hljs-number">500</span><br>fmt.Println(<span class="hljs-string">&quot;new price is&quot;</span>, price, <span class="hljs-string">&quot;new quantity is&quot;</span>, quantity)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/W2zBg9dNzNA">Run in playground</a></p><p>上面的程序将会打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">price is 0 quantity is 0<br>new price is 3000 new quantity is 500<br></code></pre></td></tr></table></figure><p>有一种情况，我们可能会想要在一条语句中定义多个变量，并且它们属于不同的数据类型。这么做的语法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fallback">var (<br>      name1 = initialvalue1<br>      name2 = initialvalue2<br>)<br></code></pre></td></tr></table></figure><p>下面的程序使用了上面的语法来声明不同类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>name   = <span class="hljs-string">&quot;Naveen&quot;</span><br>age    = <span class="hljs-number">38</span><br>height <span class="hljs-type">int</span><br>)<br>fmt.Println(<span class="hljs-string">&quot;my name is&quot;</span>, name)<br>fmt.Println(<span class="hljs-string">&quot;my age is&quot;</span>, age)<br>fmt.Println(<span class="hljs-string">&quot;my height is&quot;</span>, height)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/UMeFO9KoV-U">Run in playground</a></p><p>这里我们声明了一个<code>string</code>类型的变量<code>name</code>，<code>int</code>类型的<code>age</code>和<code>height</code>。(我们将会在<a href="../%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">下一篇</a>讨论Golang中不同类型的变量)</p><p>运行上面的程序将会打印。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fallback">my name is Naveen<br>my age is 38<br>my height is 0<br></code></pre></td></tr></table></figure><h3 id="简短声明"><a href="#简短声明" class="headerlink" title="简短声明"></a>简短声明</h3><p>Go也提供了另一种简短的声明变量方式。这就是所谓的简短声明，它使用<code>:=</code>操作符。</p><p><strong>name :&#x3D; initialvalue</strong> 是声明一个变量的简短语法。</p><p>下面的程序使用了简短语法声明了一个初始化为<code>10</code>的变量<code>count</code>。Go会自动推断出<code>count</code>是<code>int</code>类型，因为它被整型值<code>10</code>初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>count := <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;Count =&quot;</span>,count)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/9X5FGM0QYxS">Run in playground</a></p><p>上面的程序将会打印，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Count = 10<br></code></pre></td></tr></table></figure><p>使用简短声明语法声明多个变量也是可以的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>name, age := <span class="hljs-string">&quot;Naveen&quot;</span>, <span class="hljs-number">29</span> <span class="hljs-comment">//short hand declaration</span><br><br>fmt.Println(<span class="hljs-string">&quot;my name is&quot;</span>, name)<br>fmt.Println(<span class="hljs-string">&quot;my age is&quot;</span>, age)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/t_leq8orwxL">Run in playground</a></p><p>上面的程序声明了两个变量<code>name</code>和<code>age</code>，它们分别是<code>string</code>和<code>int</code>类型。</p><p>如果你运行上面的程序，你将会看到下面的内容被打印。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">my name is Naveen<br>my age is 29<br></code></pre></td></tr></table></figure><p>简短声明要求赋值左侧的所有变量都有初始值。下面的程序将会打印错误<code>assignment mismatch: 2 variables but 1 value</code>。这是因为<strong>age没有被分配值</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>name, age := <span class="hljs-string">&quot;Naveen&quot;</span> <span class="hljs-comment">//error</span><br><br>fmt.Println(<span class="hljs-string">&quot;my name is&quot;</span>, name, <span class="hljs-string">&quot;age is&quot;</span>, age)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/kM93hDPatVP">Run in playground</a></p><p>简短声明只能在**:&#x3D;**左边至少有一个新声明的变量时才可以使用。看一下下面的程序，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a, b := <span class="hljs-number">20</span>, <span class="hljs-number">30</span> <span class="hljs-comment">// declare variables a and b</span><br>fmt.Println(<span class="hljs-string">&quot;a is&quot;</span>, a, <span class="hljs-string">&quot;b is&quot;</span>, b)<br>b, c := <span class="hljs-number">40</span>, <span class="hljs-number">50</span> <span class="hljs-comment">// b is already declared but c is new</span><br>fmt.Println(<span class="hljs-string">&quot;b is&quot;</span>, b, <span class="hljs-string">&quot;c is&quot;</span>, c)<br>b, c = <span class="hljs-number">80</span>, <span class="hljs-number">90</span> <span class="hljs-comment">// assign new values to already declared variables b and c</span><br>fmt.Println(<span class="hljs-string">&quot;changed b is&quot;</span>, b, <span class="hljs-string">&quot;c is&quot;</span>, c)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/V2aMZKS5Kpj">Run in playground</a></p><p>在上面的程序中，第8行，<strong>b</strong>已经被声明过了，而<strong>c</strong>是新声明的，因此它可以正常运行并且输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fallback">a is 20 b is 30<br>b is 40 c is 50<br>changed b is 80 c is 90<br></code></pre></td></tr></table></figure><p>而如果我们运行下面的程序，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a, b := <span class="hljs-number">20</span>, <span class="hljs-number">30</span> <span class="hljs-comment">//a and b declared</span><br>fmt.Println(<span class="hljs-string">&quot;a is&quot;</span>, a, <span class="hljs-string">&quot;b is&quot;</span>, b)<br>a, b := <span class="hljs-number">40</span>, <span class="hljs-number">50</span> <span class="hljs-comment">//error, no new variables</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/SYyrrmPHMG_F">Run in playground</a></p><p>它会打印错误<code>./prog.go:8:7: no new variables on left side of :=</code>。这是因为变量<strong>a</strong>和<strong>b</strong>都已经被定义过，并且第8行**:&#x3D;**左边没有新变量了。</p><p>变量也可以分配值，这些值时在运行时计算得出的。请看下面的程序，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a, b := <span class="hljs-number">145.8</span>, <span class="hljs-number">543.8</span><br>c := math.Min(a, b)<br>fmt.Println(<span class="hljs-string">&quot;Minimum value is&quot;</span>, c)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/SVQ2RGT7JuP">Run in playground</a></p><p>在上面的程序中，<a href="https://golang.org/pkg/math/">math</a>是一个<a href="https://golangbot.com/go-packages/">包</a>，<a href="https://golang.org/pkg/math/#Min">Min</a>是那个包中的一个<a href="https://golangbot.com/functions/">函数</a>。现在不需要担心这个，我们将会在接下来的章节<a href="../%E3%80%90GolangBot%E3%80%917-%E5%8C%85/">包</a>和<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数</a>中详细介绍它们。我们现在只需要知道，<code>c</code>的值时在运行过程中计算出来的，并且它时<code>a</code>和<code>b</code>之中的最小值。上面的程序将会打印，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Minimum value is  145.8<br></code></pre></td></tr></table></figure><p>因为Go是强类型的，声明为一种类型的变量不能赋值给另外一种类型。下面的程序将会打印错误<code>cannot use &quot;Naveen&quot; (untyped string constant) as int value in assignment</code>，因为<code>age</code>声明为<code>int</code>类型，我们正尝试为它分配一个<code>string</code>值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>age := <span class="hljs-number">29</span>      <span class="hljs-comment">// age is int</span><br>age = <span class="hljs-string">&quot;Naveen&quot;</span> <span class="hljs-comment">// error since we are trying to assign a string to a variable of type int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/_L67J5Mxy8F">Run in playground</a></p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">类型</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GoLangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】2-Hello World</title>
    <link href="/%E3%80%90GolangBot%E3%80%912-Hello-World/"/>
    <url>/%E3%80%90GolangBot%E3%80%912-Hello-World/</url>
    
    <content type="html"><![CDATA[<h1 id="【GolangBot】2-Hello-World"><a href="#【GolangBot】2-Hello-World" class="headerlink" title="【GolangBot】2-Hello World"></a>【GolangBot】2-Hello World</h1><p>这是我们<a href="../golangbot/">Golang系列教程</a>的第二篇。请阅读我们前一篇教程<a href="../%E3%80%90GolangBot%E3%80%911-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/">Golang安装和介绍</a>来了解什么是Golang，以及如何安装Golang。</p><h3 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h3><p>让我们在想要写Hello World程序的位置创建一个目录。打开终端运行如下命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">mkdir ~/Documents/learngo/<br></code></pre></td></tr></table></figure><p>上面的命令将会在当前用户的文档目录下创建一个名为<code>learngo</code>的目录。你可以随意在希望存放代码的位置创建目录。</p><h3 id="创建一个Go-Module"><a href="#创建一个Go-Module" class="headerlink" title="创建一个Go Module"></a>创建一个Go Module</h3><p>下一步是在<code>~/Documents/learngo/</code>文件夹中创建一个名为<code>learngo</code>的go module。Go modules 用来追踪应用的依赖和版本。我们将会在我们学习<a href="../%E3%80%90GolangBot%E3%80%917-%E5%8C%85/">包</a>的时候详细讨论Go modules。</p><p>在<code>~/Documents/learngo/</code>目录中运行<code>go mod init learngo</code>。这将会创建一个名为<code>go.mod</code>的文件。运行<code>go mod init learngo</code>命令后，下面的内容将会被打印出来</p><p>Run <code>go mod init learngo</code> inside the <code>~/Documents/learngo/</code> directory. This will create a file named <code>go.mod</code>. The following will be printed after running the <code>go mod init learngo</code> command</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs v">go: creating <span class="hljs-keyword">new</span> go<span class="hljs-variable">.mod</span>: <span class="hljs-keyword">module</span> learngo<br></code></pre></td></tr></table></figure><p><code>go.mod</code>文件的内容如下。</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs v"><span class="hljs-keyword">module</span> learngo<br><br>go <span class="hljs-number">1</span><span class="hljs-variable">.21</span><span class="hljs-variable">.0</span><br></code></pre></td></tr></table></figure><p>The first line <code>module learngo</code> specifies the module name. The next line <code>1.21.0</code> indicates that the files in this module use go version 1.21.0</p><p>第一行<code>module learngo</code>制定了module的名称。下一行<code>1.21.0</code>表明在这个module当中，使用的go版本是1.21.0。</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>用你最喜欢的文本编辑器在<code>learngo</code>目录下创建一个名为<code>main.go</code>的文件，其中包含以下内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>&#125; <br></code></pre></td></tr></table></figure><p>按照Go的管理，包含<code>main</code>函数的文件命名为<code>main.go</code>，但其他名称也同样适用。</p><h3 id="运行go程序"><a href="#运行go程序" class="headerlink" title="运行go程序"></a>运行go程序</h3><p>有几种运行Go程序的不同方式。让我们一个个地来看。</p><h4 id="1-go-install"><a href="#1-go-install" class="headerlink" title="1. go install"></a>1. go install</h4><p>第一种运行Go程序的方法是使用<code>go install</code>命令。让我们<code>cd</code>进我们刚刚创建的<code>learngo</code>目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">cd ~/Documents/learngo/<br></code></pre></td></tr></table></figure><p>运行如下命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">go install<br></code></pre></td></tr></table></figure><p>上面的命令将会变异程序并且安装(拷贝)二进制文件到<code>~/go/bin</code>路径。二进制文件的名称是go module的名称。在我们的示例中，它会被命名为<code>learngo</code>。</p><p>当你尝试安装程序的时候，你可能会碰到下面的错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">go install: no install location for directory /home/naveen/Documents/learngo outside GOPATH<br>For more details see: &#x27;go help gopath&#x27;<br></code></pre></td></tr></table></figure><p>上面的错误通常的意思是指，<code>go install</code>找不到位置安装编译后的二进制文件。所以让我们继续，并且给他一个位置。这个位置是由<code>GOBIN</code>环境变量控制的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">export GOBIN=~/go/bin/<br></code></pre></td></tr></table></figure><p>上面的环境变量制定了<code>go install</code>应该拷贝并且编译二进制文件到<code>~go/bin</code>路径。这是对Go的二进制文件来说一个约定俗成的路径，但你也可以随心所欲的修改它到任意你想要的位置。现在试着重新运行<code>go install</code>，程序应该会正常编译并且运行了。</p><p>你可以在终端里面输入<code>ls -al ~/go/bin/learngo</code>，你会发现实际上<code>go install</code>已经把二进制文件放到了<code>~/go/bin</code>路径下。</p><p>现在，让我们来运行编译后的二进制文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">~/go/bin/learngo<br></code></pre></td></tr></table></figure><p>上面的命令将会运行<code>learngo</code>二进制文件并且打印如下输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Hello World<br></code></pre></td></tr></table></figure><p>恭喜！你已经成功运行了你的第一个Go程序。</p><p>如果你不想每次运行程序的时候都输入完整的路径<code>~/go/bin/learngo</code>，你可以把<code>~/go/bin/</code>添加到你的PATH环境变量中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">export PATH=$PATH:~/go/bin<br></code></pre></td></tr></table></figure><p>现在，你只需要在终端输入<code>learngo</code>就可以运行你的程序了。</p><p>你也许想知道当<code>learngo</code>目录包含多个go文件而不只有一个<code>main.go</code>时会发生什么。在这种情况下<code>go install</code>会发生什么？请别着急，我们将会在<a href="../%E3%80%90GolangBot%E3%80%917-%E5%8C%85/">包和Go Modules</a>一节中讨论这些。</p><h4 id="2-go-build"><a href="#2-go-build" class="headerlink" title="2. go build"></a>2. go build</h4><p>运行程序的第二个选择是使用<code>go build</code>。<code>go build</code>和<code>go install</code>非常相似，除了它不会在<code>~/go/bin/</code>路径下安装(拷贝)二进制文件。相反，它会在安装<code>go build</code>的位置创建二进制文件。</p><p>在终端输入以下命令将当前目录更改为<code>learngo</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">cd ~/Documents/learngo/<br></code></pre></td></tr></table></figure><p>在那之后，输入下面的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">go build<br></code></pre></td></tr></table></figure><p>上方的命令会在当前目录创建一个名为<code>learngo</code>的二进制文件。运行<code>ls -al</code>会发现一个名为<code>learngo</code>的文件被创建了。</p><p>输入<code>./learngo</code>运行程序。这也会打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Hello World<br></code></pre></td></tr></table></figure><p>我们用<code>go build</code>同样成功运行了我们的第一个Go程序:)</p><h4 id="3-go-run"><a href="#3-go-run" class="headerlink" title="3. go run"></a>3. go run</h4><p>第三种运行程序的方式是使用<code>go run</code>命令。</p><p>在终端中输入<code>cd ~/Documents/learngo/</code>命令来改变当前目录到<code>learngo</code>。</p><p>然后，输入如下的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">go run main.go<br></code></pre></td></tr></table></figure><p>执行上面的命令后，我们会看到输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Hello World<br></code></pre></td></tr></table></figure><p><code>go run</code>与<code>go build/go install</code>命令的一个不同就在于，<code>go run</code>需要<code>.go</code>文件的名字作为一个参数。</p><p>在底层，<code>go run</code>和<code>go build</code>非常相似。但<code>go run</code>不在当前目录编译和安装程序，而是向一个临时目录编译文件，并在该目录运行文件。如果你有兴趣想知道<code>go run</code>把文件编译到了哪里，请在运行<code>go run</code>的时候加上<code>--work</code>参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">go run --work main.go<br></code></pre></td></tr></table></figure><p>运行上面的命令，我这里输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">WORK=/tmp/go-build199689936<br>Hello World<br></code></pre></td></tr></table></figure><p>关键字<code>WORK</code>的值制定了程序将会被编译到的临时位置。在我的示例中，程序已经被编译到了<code>/tmp/go-build199689936</code>。你的运行情况可能有所不同:)</p><h4 id="4-Go在线运行环境。"><a href="#4-Go在线运行环境。" class="headerlink" title="4. Go在线运行环境。"></a>4. Go在线运行环境。</h4><p>最后一种方式是使用Go在线运行环境。尽管有一些限制，但当我们想要运行简单的程序时，此方法将会派上用场，它使用浏览器运行，不需要在本地安装GO:)。我已经为Hello World 程序创建了一个在线环境。<a href="https://go.dev/play/p/oXGayDtoLPh">点击这里</a>在线运行程序。</p><p>你也可以使用Go在线运行环境来与其他人分享你的源码。</p><p>现在我们知道了运行程序的四种不同的方式，你可能纠结于使用哪一种。答案是，视情况而定。当我想要做一个快速逻辑检查或一个标准库函数是否生效时，我一般会选择在线环境。在大多数情况下，我更喜欢<code>go install</code>，因为它给我一种选择，让我可以在终端里可以从任意目录运行程序，因为它将所有的程序编译到靠准<code>~/go/bin</code>路径。</p><h4 id="对Hello-World程序的简短解释"><a href="#对Hello-World程序的简短解释" class="headerlink" title="对Hello World程序的简短解释"></a>对Hello World程序的简短解释</h4><p>这里是我们刚刚写的Hello World程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>) <br>&#125;<br></code></pre></td></tr></table></figure><p>我们会简要讨论程序的每一行的作用。我们将在接下来的每一篇教程中深入探讨程序的各个部分。</p><p><strong>package main - 每一个go文件都必须从<code>package name</code>语句开始</strong>。包用于提供代码的分隔和可重用性。这里用到了包名<code>main</code>。<code>main</code>函数应该永远处于main包中。</p><p><strong>import “fmt”</strong> - import语句用来引用其他的包。在我们的示例中，<code>fmt</code>包被引用并且它用于在main函数中向标准输出打印文本。</p><p><strong>fmt.Println(“Hello World”)</strong> - <code>fmt</code>包的 <code>Println</code> 函数用于向标准输出打印文本。<code>package.Function()</code>是调用包内函数的格式。</p><p>代码可以在<a href="https://github.com/golangbot/hello">GitHub</a>上下载。</p><p>你现在可以去<a href="">【GolangBot】3-变量</a>来学习Go中的变量。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/">变量</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GoLangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】1.介绍和安装</title>
    <link href="/%E3%80%90GolangBot%E3%80%911-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <url>/%E3%80%90GolangBot%E3%80%911-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>发现了一个不错的英文Golang初级教程，内容比较容易理解，开个新坑，翻译一下。一来能够巩固一下GoLang基础，二来可以提高一下英文水平，如果纰漏还请指出。那我们开始吧！</p><blockquote><p><a href="https://golangbot.com/learn-golang-series/">原文地址</a></p></blockquote><h1 id="【GolangBot】1-介绍和安装"><a href="#【GolangBot】1-介绍和安装" class="headerlink" title="【GolangBot】1-介绍和安装"></a>【GolangBot】1-介绍和安装</h1><p>这是我们<a href="../golangbot/">GoLang系列教程</a>的第一篇。这篇文章提供了对于Go的介绍，也讨论了在其他众多编程语言中，选择Go的优点。我们也会学习如何在MacOS、Windows和Linux上安装MacOS。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Go，也被称为Golang，是由Google开发的开源、编译型、静态类型编程语言。Go创立背后的关键人物是<a href="https://zh.wikipedia.org/wiki/Rob_Pike">Rob Pike</a>、<a href="https://zh.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a>和Robert Griesemer。Go于2009年11月公开发布。</p><p>Go是一种语法简单的通用语言，并且有强大的标准库支持。Go的主要优势之一是创建高度可用且扩展的Web应用。Go也可以用来创建命令行应用、桌面应用，甚至是移动应用。</p><h3 id="Go的优势"><a href="#Go的优势" class="headerlink" title="Go的优势"></a>Go的优势</h3><p>既然有Python、Ruby、NodeJS等大量其他语言可以完成相同的工作，为什么还要选择Go来作为你的服务端编程语言呢？</p><p>以下是我在选择Go时发现的一些优点。</p><h4 id="简单的语法"><a href="#简单的语法" class="headerlink" title="简单的语法"></a>简单的语法</h4><p>Go的语法简洁明了，没有多余的功能。这使得编写可读性和可维护性良好的代码变得容易。</p><h4 id="容易编写并发程序"><a href="#容易编写并发程序" class="headerlink" title="容易编写并发程序"></a>容易编写并发程序</h4><p><a href="../%E3%80%90GolangBot%E3%80%9120-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D/">并发性</a>是Go语言的固有部分。因此，对于Go来说，编写多线程程序是小菜一碟。这是通过<a href="../%E3%80%90GolangBot%E3%80%9121-Goroutines/">Goroutines</a>和<a href="../%E3%80%90GolangBot%E3%80%9122-Channels/">Channels</a>实现的，我们将在接下来的教程讨论他们。</p><h4 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h4><p>Go是一种编译型语言。源代码被编译成原生二进制文件。这种特性是诸如nodejs所使用的Javascript这类解释型语言所没有的。</p><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>Go编译器支持静态链接。整个Go工程都可以静态链接刀一个非常大的二进制文件中，并且可以很容易地部署在云服务器上，而且不需要为各种依赖所困扰。</p><h4 id="Go工具链"><a href="#Go工具链" class="headerlink" title="Go工具链"></a>Go工具链</h4><p>Go的工具链特别值得提一下。Go附送了一套强大的工具，可以帮助开发者编写更好的代码。一些常用的工具有：</p><ul><li>gofmt - <a href="https://pkg.go.dev/cmd/gofmt">gofmt</a>用于自动格式化Go的源代码。他使用制表符进行锁紧，使用空格进行对齐。</li><li>vet - <a href="https://pkg.go.dev/cmd/vet">vet</a>分析go的源代码，并且报告可疑的代码。vet报告的不是真正的问题，而是编译器不能捕获的错误。比如使用<a href="https://pkg.go.dev/fmt#Printf">Printf</a>时使用了错误的格式指定符。</li><li>staticcheck - <a href="https://staticcheck.dev/">staticcheck</a>用来强制执行代码中的样式问题。</li></ul><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>Go使用垃圾收集机制，因此内存管理基本是自动完成的，开发者不需要担心内存管理。这也有助于轻松编写并发程序。</p><h4 id="简单的语言规范"><a href="#简单的语言规范" class="headerlink" title="简单的语言规范"></a>简单的语言规范</h4><p>语言规范十分简单。<a href="go.dev/ref/spec">整个规范</a>都有详细的记录，你甚至可以用它来编写自己的编译器:)。</p><h4 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h4><p>最后，同样重要的是，Go是一个开雨啊项目。你可以参与<a href="https://go.dev/doc/contribute">Go项目</a>并为其作出贡献。</p><h3 id="使用Go构建的热门产品"><a href="#使用Go构建的热门产品" class="headerlink" title="使用Go构建的热门产品"></a>使用Go构建的热门产品</h3><p>下面是一些使用Go构建的热门产品。</p><ul><li>谷歌使用Go开发了Kubernetes。</li><li>Docker，世界闻名的容器化平台是用Go开发的。</li><li>Dropbox一讲起性能关键组件从Python移植到了Go。</li><li>Infoblox’s 的下一代网络产品时使用Go开发的。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Go可以安装在所有的三种平台上：Mac、Windows和Linux。你可以从 <a href="https://go.dev/dl/">https://go.dev/dl/</a> 下载对应平台的二进制文件。</p><h4 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h4><p>从 <a href="https://go.dev/dl/">https://go.dev/dl/</a> 下载Mac OS安装器。双击开始安装。根据提示操作，Golang将会安装在<code>/usr/local/go</code>并且会把 <code>/usr/local/go/bin</code>这个文件夹添加到你的PATH环境变量中。</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>从 <a href="https://go.dev/dl/">https://go.dev/dl/</a> 下载MSI安装器。双击开始安装，并根据提示进行操作。这将会把Go安装在<code>c:\Go</code>，并且会把目录 <code>c:\Go\bin</code>添加到path环境变量。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>从 <a href="https://go.dev/dl/">https://go.dev/dl/</a> 下载tar文件并且解压至<code>/usr/local</code>。添加<code>/usr/local/go/bin</code>到PATH环境变量。这将在Linux中安装Go。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>To verify that Go installed successfully, type the command <code>go version</code> in the terminal and it will output the installed Go version. Here is the output in my terminal.</p><p>要验证Go是否安装成功，在终端输入<code>go version</code>命令，它会输出安装好的Go版本。这是我的终端输出的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">$ go version<br>go version go1.19.2 linux/amd64<br></code></pre></td></tr></table></figure><p><code>1.19.2</code>是在写这篇教程时最新的版本。这证实Go确实安装成功了。在下一篇教程中，我们将会用Go写我们的第一个<a href="../%E3%80%90GolangBot%E3%80%912-Hello-World/">Hello World程序</a>。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%912-Hello-World/">Hello World</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GoLangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub + PicGo 搭建个人图床</title>
    <link href="/GitHub-PicGo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/GitHub-PicGo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="GitHub-PicGo-搭建个人图床"><a href="#GitHub-PicGo-搭建个人图床" class="headerlink" title="GitHub + PicGo 搭建个人图床"></a>GitHub + PicGo 搭建个人图床</h1><p>最近开始了写博客计划，一般写Markdown的时候一般都喜欢用Typora，但是如果不用图床的话，很多图片上传后是无法显示的，因此用GitHub和PicGo搞一个图床，还方便一点。步骤也不是很麻烦，五分钟之内就能搞好。</p><h2 id="1-新建GitHub仓库"><a href="#1-新建GitHub仓库" class="headerlink" title="1.新建GitHub仓库"></a>1.新建GitHub仓库</h2><p>新建一个GitHub仓库，名字无所谓，自己记住就好。比如我这里创建一个名为<code>ImageRepo</code>的仓库。</p><h2 id="2-创建Token"><a href="#2-创建Token" class="headerlink" title="2.创建Token"></a>2.创建Token</h2><p>点击GitHub头像，选择<code>Settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Tokens(classic)-&gt;Generate new token-&gt;classic</code>。</p><p><a href="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111650090.png"><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111650090.png" alt="image-20241216111650090"></a></p><p>将这个token复制好，一会会用到。</p><h2 id="3-下载PicGo-APP"><a href="#3-下载PicGo-APP" class="headerlink" title="3.下载PicGo APP"></a>3.下载PicGo APP</h2><p><a href="https://molunerfinn.com/PicGo/">PicGo官网</a></p><p>我这里用的是macOS，下的就是dmg，根据自己的操作系统下载对应版本即可。</p><h2 id="4-配置PicGo"><a href="#4-配置PicGo" class="headerlink" title="4.配置PicGo"></a>4.配置PicGo</h2><p>打开刚才下好的APP，选择<code>图床设置-&gt;GitHub</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216150755514.png" alt="image-20241216150755514"></p><p>如果只用这一个图床，可以直接修改默认配置：</p><ul><li>图床配置名：<code>任意</code></li><li>设定仓库名：<code>username/repoName</code>(根据自己的仓库设置：username是你的GitHub名字，repoName是仓库名字)</li><li>设定分支名：<code>main</code>(如果有其他分支，根据需要设置即可)</li><li>设定Token：刚才从GitHub复制的token</li><li>设定存储路径：根据自己需要设置</li><li>设定自定义域名：<code>https://cdn.jsdelivr.net/gh/username/repoName</code>(username和repoName同上)</li></ul><p>点击保存，这样就设置完成了。可以在上传区上传一张照片测试一下，如果在相册中出现，说明已经成功了。</p><h2 id="5-配置Typora"><a href="#5-配置Typora" class="headerlink" title="5.配置Typora"></a>5.配置Typora</h2><p>打开Typora设置，按照图上进行修改：插入图片时选择上传图片；上传服务选择PicGo APP。Windows可能还需要选择一下APP的路径，大同小异。<img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216151227572.png" alt="image-20241216151227572"></p><hr><p>至此配置就全部完成了，我们就可以用Typora愉快的插入图片，而不用担心图片的现实问题了。但在不使用特殊手段的情况下，GitHub图床可能对墙内用户不那么友好，请自行取舍。</p><blockquote><p>参考：</p><p><a href="https://www.bilibili.com/opus/916418138329841670">如何使用GitHub搭建个人图床，配合typora使用</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>胡乱捣鼓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>PicGo</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + GitHub Actions + Page部署自动化博客</title>
    <link href="/Hexo-GitHub-Actions-Page%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/"/>
    <url>/Hexo-GitHub-Actions-Page%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-GitHub-Actions-Page部署自动化博客"><a href="#Hexo-GitHub-Actions-Page部署自动化博客" class="headerlink" title="Hexo + GitHub Actions + Page部署自动化博客"></a>Hexo + GitHub Actions + Page部署自动化博客</h1><p>最近想部署一个博客，网上看了很多相关的教程，但大部分都要么版本不一样了，要么缺少关键步骤。不如自己总结一下，来一个自己认为比较全面的，希望能给后面有相关需求的朋友一点帮助。</p><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>。</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><blockquote><p>Mac 用户</p><p>如果在编译时可能会遇到问题。 请先到 App Store 安装 Xcode。 Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p></blockquote><h2 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2.安装NodeJs"></a>2.安装NodeJs</h2><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/zh-cn/download/">安装程序</a>。</p><p>其它的安装方法：</p><ul><li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li><li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li><li>Linux（DEB&#x2F;RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li><li>其它：使用相应的软件包管理器进行安装。 可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a>。</li></ul><p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。</p><blockquote><p>Windows</p><p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）<br>Mac &#x2F; Linux</p><p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">由 npmjs 发布的指导</a> 修复该问题。<br>Linux</p><p>如果您使用 Snap 来安装 Node.js，在 <a href="https://hexo.io/zh-cn/docs/commands#init">初始化</a> 博客时您可能需要手动在目标文件夹中执行 <code>npm install</code>。</p></blockquote><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>Hexo可以使用npm进行安装,但在使用前,最好配置一下镜像.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com<br></code></pre></td></tr></table></figure><p>配置完镜像后,即可使用npm进行安装.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h2 id="4-使用Hexo建站"><a href="#4-使用Hexo建站" class="headerlink" title="4.使用Hexo建站"></a>4.使用Hexo建站</h2><p>为了方便和上手，这里使用Vscode+git操作。</p><p>安装完Hexo之后,就可以在本地选择一个文件夹,开始建站了。比如我要在本地创建一个名为Hexo的文件夹。</p><p>使用Vscode打开这个文件夹，新建一个终端，运行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br>npm install<br></code></pre></td></tr></table></figure><p>如果<code>npm install</code>失败，可以尝试删除文件夹中的<code>node_modules</code>文件夹重试。</p><p>等到npm命令执行完毕，Hexo目录中会出现如下结构。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── _config<span class="hljs-selector-class">.landscape</span><span class="hljs-selector-class">.yml</span><br>├── _config<span class="hljs-selector-class">.yml</span><br>├── node_modules<br>├── package-lock<span class="hljs-selector-class">.json</span><br>├── package<span class="hljs-selector-class">.json</span><br>├── pnpm-lock<span class="hljs-selector-class">.yaml</span><br>├── scaffolds<br>├── <span class="hljs-selector-tag">source</span><br>└── themes<br></code></pre></td></tr></table></figure><p>初始化完成后，将目录中的内容推送至仓库的main分支，这里我选择使用Vscode+git更方便的进行创建并推送。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111417720.png" alt="image-20241216111417720"></p><h2 id="5-创建Token。"><a href="#5-创建Token。" class="headerlink" title="5.创建Token。"></a>5.创建Token。</h2><p>点击GitHub头像，选择<code>Settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Tokens(classic)-&gt;Generate new token-&gt;classic</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111650090.png" alt="image-20241216111650090"></p><p>勾选<code>repo</code>和<code>workflow</code>，Note填入<code>GH_TOKEN</code>(其实都可以，与后面对应即可，如果不熟悉就跟着来吧)。有效期根据自己的需要选择。设置完成后点击生成，然后复制生成的token，注意保存，token只能查看一次，如果忘记了后面需要重新生成。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111819418.png" alt="image-20241216111819418"></p><h2 id="6-将创建的token放入仓库内。"><a href="#6-将创建的token放入仓库内。" class="headerlink" title="6.将创建的token放入仓库内。"></a>6.将创建的token放入仓库内。</h2><p>进入刚才推送出来的仓库，选择<code>Settings-&gt;Secrets and Variables-&gt;Actions-&gt;New repository secret</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216112206006.png" alt="image-20241216112206006"></p><p>将刚才我们复制的token填入，名称填写<code>GH_TOKEN</code>。</p><h2 id="7-配置仓库地址。"><a href="#7-配置仓库地址。" class="headerlink" title="7.配置仓库地址。"></a>7.配置仓库地址。</h2><p>回到Vscode，找到我们新建文件夹中的<code>_config.yml</code>文件，拉到最下方，将配置进行如下修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/ZoeKyHein/Hexo.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br></code></pre></td></tr></table></figure><p>仓库名称和地址根据自己的，灵活修改。</p><h2 id="8-配置GitHub-Actions工作流"><a href="#8-配置GitHub-Actions工作流" class="headerlink" title="8.配置GitHub Actions工作流"></a>8.配置GitHub Actions工作流</h2><p>在<code>.github</code>目录下新建一个名为<code>workflows</code>的文件夹(注意是有s的)。在其中新建一个名为<code>deploy.yml</code>的文件，复制以下内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <span class="hljs-comment"># default branch</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># If your repository depends on submodule, please see: https://github.com/actions/checkout</span><br>          <span class="hljs-attr">submodules:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># Examples: 20, 18.19, &gt;=16.20.2, lts/Iron, lts/Hydrogen, *, latest, current, node</span><br>          <span class="hljs-comment"># Ref: https://github.com/actions/setup-node#supported-version-syntax</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;22&quot;</span><br><br>     <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Git</span> <span class="hljs-string">Deployer</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm install hexo-deployer-git --save</span><br><span class="hljs-string">          npm install hexo-cli -g</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Clean</span> <span class="hljs-string">and</span> <span class="hljs-string">Generate</span> <span class="hljs-string">Static</span> <span class="hljs-string">Files</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string">          hexo generate</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">Git</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          git config --global user.name &#x27;github-actions[bot]&#x27;</span><br><span class="hljs-string">          git config --global user.email &#x27;github-actions[bot]@users.noreply.github.com&#x27;</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">GH_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GH_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          cd public/</span><br><span class="hljs-string">          git init</span><br><span class="hljs-string">          git add -A</span><br><span class="hljs-string">          git commit -m &quot;Create by workflows&quot;</span><br><span class="hljs-string">          git remote add origin https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@github.com/ZoeKyHein/Hexo.git</span><br><span class="hljs-string">          git push origin HEAD:gh-pages -f</span><br></code></pre></td></tr></table></figure><p>其中有两个位置需要修改：</p><ul><li>一是node版本需要与本地对应。在本地运行<code>node -v</code>得到版本，替换上面的<code>22</code>。</li><li>二是最下方仓库地址修改为自己的仓库路径。</li></ul><p>其实Actions工作流的本质就是，当你提交git时，自动帮你把markdown转静态网页，发布等工作给做了。相当于我们在后续维护博客的过程中，只需要使用git提交即可，后续操作都会自动帮我们完成。</p><p>修改完成后，将刚才的所有修改全部推送上去，查看GitHub仓库的<code>Action</code>是否有工作流工作。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216113145810.png" alt="image-20241216113145810"></p><p>正常情况下，该工作流前面会有一个✅标志，表示没有错误发生，正常进行。</p><p>回到<code>Code</code>，查看是否出现了<code>gh-pages</code>分支，并检查<code>gh-pages</code>分支下的<code>index.html</code>文件是否为空，如果为空，需要根据工作流日志查阅一下问题。</p><h2 id="9-配置GitHub-Pages"><a href="#9-配置GitHub-Pages" class="headerlink" title="9.配置GitHub Pages"></a>9.配置GitHub Pages</h2><p>进入到仓库，选择<code>Settings-&gt;Pages</code>,确保分支时<code>gh-pages</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216113459989.png" alt="image-20241216113459989"></p><p>关于网站的访问地址，可以在图中上方红框框起来的区域查看。规则如下：</p><ul><li>如果想要通过<code>https://username.github.io</code>直接访问，需要把仓库名称修改为<code>username.github.io</code>，且这样不会出现外部文件引用出错的问题，<strong>推荐</strong>。</li><li>如果想要通过<code>https://username.github.io/xxx</code>访问，仓库名字设置为<code>xxx</code>，但这样需要多配置一步，来解决外部文件的引用错误。</li></ul><p>访问网站，如果你用的是第一种，那么应该可以看到Hexo的默认页面。(这里图片是使用了主题，所以看起来可能与你的不太一样，问题不大，意思到了就好)</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216114436636.png" alt="image-20241216114436636"></p><p>如果是第二种，需要回到配置文件<code>_config.yml</code>，解决一下资源请求的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216114239466.png" alt="image-20241216114239466"></p><p>将<code>url</code>字段修改为仓库的地址，<code>root</code>字段修改为仓库名称。可以顺手将<code>post_asset_folder</code>属性修改为<code>true</code>来解决图片不显示的问题。</p><h2 id="10-修改主题"><a href="#10-修改主题" class="headerlink" title="10.修改主题"></a>10.修改主题</h2><p>至此，默认的Hexo的配置已经完成了。下面来说一下如何更改主题，我这里用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>，以这个为例。每个主题一般都会提供安装文档。按照安装文档一步步进行即可。</p><hr><p>至此，就已经完成了全部配置，可以开始自己的博客写作之路了。</p><blockquote><p>参考资料：</p><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p><p><a href="https://www.bilibili.com/video/BV1xTgTemEDU/?spm_id_from=333.337.search-card.all.click&vd_source=54e860cc95e5fe130d79a442d282774f">9分钟零成本搭建自动化部署个人博客(Hexo + Github Action + Page)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>胡乱捣鼓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
